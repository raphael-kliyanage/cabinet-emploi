exports.load = function(_cli_pkg_requires) {
// make sure to keep this as 'var'
// we don't want block scoping

var dartNodePreambleSelf = typeof global !== "undefined" ? global : window;

var self = Object.create(dartNodePreambleSelf);

self.scheduleImmediate = typeof setImmediate !== "undefined"
    ? function (cb) {
        setImmediate(cb);
      }
    : function(cb) {
        setTimeout(cb, 0);
      };

// CommonJS globals.
self.exports = exports;

// Node.js specific exports, check to see if they exist & or polyfilled

if (typeof process !== "undefined") {
  self.process = process;
}

if (typeof __dirname !== "undefined") {
  self.__dirname = __dirname;
}

if (typeof __filename !== "undefined") {
  self.__filename = __filename;
}

if (typeof Buffer !== "undefined") {
  self.Buffer = Buffer;
}

// if we're running in a browser, Dart supports most of this out of box
// make sure we only run these in Node.js environment

var dartNodeIsActuallyNode = !dartNodePreambleSelf.window

try {
  // Check if we're in a Web Worker instead.
  if ("undefined" !== typeof WorkerGlobalScope && dartNodePreambleSelf instanceof WorkerGlobalScope) {
    dartNodeIsActuallyNode = false;
  }

  // Check if we're in Electron, with Node.js integration, and override if true.
  if ("undefined" !== typeof process && process.versions && process.versions.hasOwnProperty('electron') && process.versions.hasOwnProperty('node')) {
    dartNodeIsActuallyNode = true;
  }
} catch(e) {}

if (dartNodeIsActuallyNode) {
  // This line is to:
  // 1) Prevent Webpack from bundling.
  // 2) In Webpack on Node.js, make sure we're using the native Node.js require, which is available via __non_webpack_require__
  // https://github.com/mbullington/node_preamble.dart/issues/18#issuecomment-527305561
  var url = ("undefined" !== typeof __webpack_require__ ? __non_webpack_require__ : require)("url");

  // Setting `self.location=` in Electron throws a `TypeError`, so we define it
  // as a property instead to be safe.
  Object.defineProperty(self, "location", {
    value: {
      get href() {
        if (url.pathToFileURL) {
          return url.pathToFileURL(process.cwd()).href + "/";
        } else {
          // This isn't really a correct transformation, but it's the best we have
          // for versions of Node <10.12.0 which introduced `url.pathToFileURL()`.
          // For example, it will fail for paths that contain characters that need
          // to be escaped in URLs.
          return "file://" + (function() {
            var cwd = process.cwd();
            if (process.platform != "win32") return cwd;
            return "/" + cwd.replace(/\\/g, "/");
          })() + "/"
        }
      }
    }
  });

  (function() {
    function computeCurrentScript() {
      try {
        throw new Error();
      } catch(e) {
        var stack = e.stack;
        var re = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "mg");
        var lastMatch = null;
        do {
          var match = re.exec(stack);
          if (match != null) lastMatch = match;
        } while (match != null);
        return lastMatch[1];
      }
    }

    // Setting `self.document=` isn't known to throw an error anywhere like
    // `self.location=` does on Electron, but it's better to be future-proof
    // just in case..
    var cachedCurrentScript = null;
    Object.defineProperty(self, "document", {
      value: {
        get currentScript() {
          if (cachedCurrentScript == null) {
            cachedCurrentScript = {src: computeCurrentScript()};
          }
          return cachedCurrentScript;
        }
      }
    });
  })();

  self.dartDeferredLibraryLoader = function(uri, successCallback, errorCallback) {
    try {
     load(uri);
      successCallback();
    } catch (error) {
      errorCallback(error);
    }
  };
}

self.util = require("util");
self.immutable = require("immutable");
self.fs = require("fs");
self.chokidar = _cli_pkg_requires.chokidar;
self.readline = _cli_pkg_requires.readline;
// Generated by dart2js (NullSafetyMode.sound, trust primitives, omit checks, lax runtime type, no-legacy-javascript), the Dart to JavaScript compiler version: 2.14.4.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback, loadId):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error. The loadId argument is the deferred import that resulted in
//    this uri being loaded.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  function mixinProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!to.hasOwnProperty(key))
        to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == "function")
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    mixinProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazyOld(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel)
        holder[name] = initializer();
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function lazyFinal(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        var value = initializer();
        if (holder[name] !== uninitializedSentinel)
          H.throwLateFieldADI(name);
        holder[name] = value;
      }
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function instanceTearOffGetter(isIntercepted, parameters) {
    var name = parameters.fs[0];
    if (isIntercepted)
      return new Function("parameters, createTearOffClass, cache", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (cache === null) cache = createTearOffClass(parameters);" + "return new cache(receiver, this);" + "}")(parameters, H.closureFromTearOff, null);
    else
      return new Function("parameters, createTearOffClass, cache", "return function tearOff_" + name + functionCounter++ + "() {" + "if (cache === null) cache = createTearOffClass(parameters);" + "return new cache(this, null);" + "}")(parameters, H.closureFromTearOff, null);
  }
  function staticTearOffGetter(parameters) {
    var cache = null;
    return function() {
      if (cache === null)
        cache = H.closureFromTearOff(parameters).prototype;
      return cache;
    };
  }
  var typesOffset = 0;
  function tearOffParameters(container, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    if (typeof funType == "number")
      funType += typesOffset;
    return {co: container, iS: isStatic, iI: isIntercepted, rC: requiredParameterCount, dV: optionalParameterDefaultValues, cs: callNames, fs: funsOrNames, fT: funType, aI: applyIndex || 0, nDA: needsDirectAccess};
  }
  function installStaticTearOff(holder, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var parameters = tearOffParameters(holder, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, false);
    var getterFunction = staticTearOffGetter(parameters);
    holder[getterName] = getterFunction;
  }
  function installInstanceTearOff(prototype, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    isIntercepted = !!isIntercepted;
    var parameters = tearOffParameters(prototype, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, !!needsDirectAccess);
    var getterFunction = instanceTearOffGetter(isIntercepted, parameters);
    prototype[getterName] = getterFunction;
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex, false);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, lazyFinal: lazyFinal, lazyOld: lazyOld, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  var A = {MapExpression: function MapExpression(t0, t1) {
      this.pairs = t0;
      this.span = t1;
    }, MapExpression_toString_closure: function MapExpression_toString_closure() {
    }, IncludeRule: function IncludeRule(t0, t1, t2, t3, t4) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.content = t3;
      _.span = t4;
    }, Configuration: function Configuration(t0) {
      this._values = t0;
    }, Configuration_toString_closure: function Configuration_toString_closure() {
    }, ExplicitConfiguration: function ExplicitConfiguration(t0, t1) {
      this.nodeWithSpan = t0;
      this._values = t1;
    },
    watch(options, graph) {
      return A.watch$body(options, graph);
    },
    watch$body(options, graph) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, t1, t2, t3, t4, t5, t6, dirWatcher, watcher;
      var $async$watch = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              options._ensureSources$0();
              t1 = type$.String;
              t2 = options.get$_sourceDirectoriesToDestinations().cast$2$0(0, t1, t1);
              t2 = P.List_List$of(t2.get$keys(t2), true, t1);
              for (options._ensureSources$0(), t3 = options._sourcesToDestinations.cast$2$0(0, t1, t1), t3 = J.get$iterator$ax(t3.get$keys(t3)); t3.moveNext$0();) {
                t4 = t3.get$current(t3);
                t2.push($.$get$context().dirname$1(t4));
              }
              t3 = options._options;
              C.JSArray_methods.addAll$1(t2, type$.List_String._as(t3.$index(0, "load-path")));
              t4 = H._asBool(t3.$index(0, "poll"));
              t5 = type$.Stream_WatchEvent;
              t6 = K.PathMap__create(null, t5);
              t5 = new L.StreamGroup(C._StreamGroupState_dormant, P.LinkedHashMap_LinkedHashMap$_empty(t5, type$.nullable_StreamSubscription_WatchEvent), type$.StreamGroup_WatchEvent);
              t5.__StreamGroup__controller = P.StreamController_StreamController(t5.get$_onCancel(), t5.get$_onListen(), t5.get$_onPause(), t5.get$_onResume(), true, type$.WatchEvent);
              dirWatcher = new U.MultiDirWatcher(new K.PathMap(t6, type$.PathMap_Stream_WatchEvent), t5, t4);
              $async$goto = 3;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(t2, new A.watch_closure(dirWatcher), H._arrayInstanceType(t2)._eval$1("MappedListIterable<1,Future<~>>")), type$.void), $async$watch);
            case 3:
              // returning from await.
              watcher = new A._Watcher(options, graph);
              options._ensureSources$0(), t1 = options._sourcesToDestinations.cast$2$0(0, t1, t1), t1 = t1.get$entries(t1), t1 = t1.get$iterator(t1);
            case 4:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 5;
                break;
              }
              t2 = t1.get$current(t1);
              t4 = $.$get$context();
              t5 = t4.absolute$7(".", null, null, null, null, null, null);
              t6 = t2.key;
              graph.addCanonical$4$recanonicalize(new F.FilesystemImporter(t5), t4.toUri$1(J.$eq$(J.get$platform$x(self.process), "win32") || J.$eq$(J.get$platform$x(self.process), "darwin") ? F._realCasePath(t4.absolute$7(t4.normalize$1(t6), null, null, null, null, null, null)) : t4.canonicalize$1(0, t6)), t4.toUri$1(t6), false);
              $async$goto = 6;
              return P._asyncAwait(watcher.compile$3$ifModified(0, t6, t2.value, true), $async$watch);
            case 6:
              // returning from await.
              if (!$async$result && H._asBool(t3.$index(0, "stop-on-error"))) {
                t1 = dirWatcher._group.__StreamGroup__controller;
                if (t1 == null)
                  t1 = H.throwExpression(H.LateError$fieldNI("_controller"));
                t1._subscribe$4(null, null, null, false).cancel$0();
                // goto return
                $async$goto = 1;
                break;
              }
              // goto for condition
              $async$goto = 4;
              break;
            case 5:
              // after for
              P.print("Sass is watching for changes. Press Ctrl-C to stop.\n");
              $async$goto = 7;
              return P._asyncAwait(watcher.watch$1(0, dirWatcher), $async$watch);
            case 7:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$watch, $async$completer);
    },
    watch_closure: function watch_closure(t0) {
      this.dirWatcher = t0;
    },
    _Watcher: function _Watcher(t0, t1) {
      this._watch$_options = t0;
      this._graph = t1;
    },
    _Watcher__debounceEvents_closure: function _Watcher__debounceEvents_closure() {
    },
    MergedExtension_merge(left, right) {
      var t4, t5, t6,
        t1 = left.extender,
        t2 = t1.selector,
        t3 = C.C_ListEquality.equals$2(0, t2.components, right.extender.selector.components);
      if (!t3 || !left.target.$eq(0, right.target))
        throw H.wrapException(P.ArgumentError$(left.toString$0(0) + " and " + right.toString$0(0) + " aren't the same extension.", null));
      t3 = left.mediaContext;
      t4 = t3 == null;
      if (!t4) {
        t5 = right.mediaContext;
        t5 = t5 != null && !C.C_ListEquality.equals$2(0, t3, t5);
      } else
        t5 = false;
      if (t5)
        throw H.wrapException(E.SassException$("From " + left.span.message$1(0, "") + string$.x0aYou_m, right.span));
      if (right.isOptional && right.mediaContext == null)
        return left;
      if (left.isOptional && t4)
        return right;
      t5 = left.target;
      t6 = left.span;
      if (t4)
        t3 = right.mediaContext;
      t2.get$maxSpecificity();
      t1 = new S.Extender(t2, false, t1.span);
      return t1._extension = new A.MergedExtension(left, right, t1, t5, t3, true, t6);
    },
    MergedExtension: function MergedExtension(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.extender = t2;
      _.target = t3;
      _.mediaContext = t4;
      _.isOptional = t5;
      _.span = t6;
    },
    _modify(map, keys, modify, addNesting) {
      var keyIterator = J.get$iterator$ax(keys);
      return keyIterator.moveNext$0() ? new A._modify__modifyNestedMap(keyIterator, modify, addNesting).call$1(map) : modify.call$1(map);
    },
    _deepMergeImpl(map1, map2) {
      var t1 = {},
        t2 = map2._map$_contents;
      if (t2.get$isEmpty(t2))
        return map1;
      t1.mutable = false;
      t1.result = t2;
      map1._map$_contents.forEach$1(0, new A._deepMergeImpl_closure(t1, new A._deepMergeImpl__ensureMutable(t1)));
      if (t1.mutable) {
        t2 = type$.Value;
        t2 = new A.SassMap(H.ConstantMap_ConstantMap$from(t1.result, t2, t2));
        t1 = t2;
      } else
        t1 = map2;
      return t1;
    },
    _function2($name, $arguments, callback) {
      return Q.BuiltInCallable$function($name, $arguments, callback, "sass:map");
    },
    _get_closure: function _get_closure() {
    },
    _set_closure: function _set_closure() {
    },
    _set__closure0: function _set__closure0(t0) {
      this.$arguments = t0;
    },
    _set_closure0: function _set_closure0() {
    },
    _set__closure: function _set__closure(t0) {
      this.args = t0;
    },
    _merge_closure: function _merge_closure() {
    },
    _merge_closure0: function _merge_closure0() {
    },
    _merge__closure: function _merge__closure(t0) {
      this.map2 = t0;
    },
    _deepMerge_closure: function _deepMerge_closure() {
    },
    _deepRemove_closure: function _deepRemove_closure() {
    },
    _deepRemove__closure: function _deepRemove__closure(t0) {
      this.keys = t0;
    },
    _remove_closure: function _remove_closure() {
    },
    _remove_closure0: function _remove_closure0() {
    },
    _keys_closure: function _keys_closure() {
    },
    _values_closure: function _values_closure() {
    },
    _hasKey_closure: function _hasKey_closure() {
    },
    _modify__modifyNestedMap: function _modify__modifyNestedMap(t0, t1, t2) {
      this.keyIterator = t0;
      this.modify = t1;
      this.addNesting = t2;
    },
    _deepMergeImpl__ensureMutable: function _deepMergeImpl__ensureMutable(t0) {
      this._box_0 = t0;
    },
    _deepMergeImpl_closure: function _deepMergeImpl_closure(t0, t1) {
      this._box_0 = t0;
      this._ensureMutable = t1;
    },
    SassMap: function SassMap(t0) {
      this._map$_contents = t0;
    },
    SassMap_asList_closure: function SassMap_asList_closure(t0) {
      this.result = t0;
    },
    _IterableExtension__search(_this, callback) {
      var t1, value;
      for (t1 = J.get$iterator$ax(_this); t1.moveNext$0();) {
        value = callback.call$1(t1.get$current(t1));
        if (value != null)
          return value;
      }
    },
    StatementSearchVisitor: function StatementSearchVisitor() {
    },
    StatementSearchVisitor_visitIfRule_closure: function StatementSearchVisitor_visitIfRule_closure(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure0: function StatementSearchVisitor_visitIfRule__closure0(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule_closure0: function StatementSearchVisitor_visitIfRule_closure0(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure: function StatementSearchVisitor_visitIfRule__closure(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitChildren_closure: function StatementSearchVisitor_visitChildren_closure(t0) {
      this.$this = t0;
    },
    Frame_Frame$parseVM(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseVM_closure(frame));
    },
    Frame_Frame$parseV8(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseV8_closure(frame));
    },
    Frame_Frame$_parseFirefoxEval(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$_parseFirefoxEval_closure(frame));
    },
    Frame_Frame$parseFirefox(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFirefox_closure(frame));
    },
    Frame_Frame$parseFriendly(frame) {
      return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFriendly_closure(frame));
    },
    Frame__uriOrPathToUri(uriOrPath) {
      if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__uriRegExp()))
        return P.Uri_parse(uriOrPath);
      else if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__windowsRegExp()))
        return P._Uri__Uri$file(uriOrPath, true);
      else if (C.JSString_methods.startsWith$1(uriOrPath, "/"))
        return P._Uri__Uri$file(uriOrPath, false);
      if (C.JSString_methods.contains$1(uriOrPath, "\\"))
        return $.$get$windows().toUri$1(uriOrPath);
      return P.Uri_parse(uriOrPath);
    },
    Frame__catchFormatException(text, body) {
      var t1, exception;
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        if (type$.FormatException._is(H.unwrapException(exception)))
          return new N.UnparsedFrame(P._Uri__Uri(null, "unparsed", null, null), text);
        else
          throw exception;
      }
    },
    Frame: function Frame(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.line = t1;
      _.column = t2;
      _.member = t3;
    },
    Frame_Frame$parseVM_closure: function Frame_Frame$parseVM_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure: function Frame_Frame$parseV8_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseV8_closure_parseLocation: function Frame_Frame$parseV8_closure_parseLocation(t0) {
      this.frame = t0;
    },
    Frame_Frame$_parseFirefoxEval_closure: function Frame_Frame$_parseFirefoxEval_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFirefox_closure: function Frame_Frame$parseFirefox_closure(t0) {
      this.frame = t0;
    },
    Frame_Frame$parseFriendly_closure: function Frame_Frame$parseFriendly_closure(t0) {
      this.frame = t0;
    },
    AsciiGlyphSet: function AsciiGlyphSet() {
    },
    Configuration0: function Configuration0(t0) {
      this._configuration$_values = t0;
    },
    Configuration_toString_closure0: function Configuration_toString_closure0() {
    },
    ExplicitConfiguration0: function ExplicitConfiguration0(t0, t1) {
      this.nodeWithSpan = t0;
      this._configuration$_values = t1;
    },
    IncludeRule0: function IncludeRule0(t0, t1, t2, t3, t4) {
      var _ = this;
      _.namespace = t0;
      _.name = t1;
      _.$arguments = t2;
      _.content = t3;
      _.span = t4;
    },
    MapExpression0: function MapExpression0(t0, t1) {
      this.pairs = t0;
      this.span = t1;
    },
    MapExpression_toString_closure0: function MapExpression_toString_closure0() {
    },
    _modify0(map, keys, modify, addNesting) {
      var keyIterator = J.get$iterator$ax(keys);
      return keyIterator.moveNext$0() ? new A._modify__modifyNestedMap0(keyIterator, modify, addNesting).call$1(map) : modify.call$1(map);
    },
    _deepMergeImpl0(map1, map2) {
      var t1 = {},
        t2 = map2._map0$_contents;
      if (t2.get$isEmpty(t2))
        return map1;
      t1.mutable = false;
      t1.result = t2;
      map1._map0$_contents.forEach$1(0, new A._deepMergeImpl_closure0(t1, new A._deepMergeImpl__ensureMutable0(t1)));
      if (t1.mutable) {
        t2 = type$.Value_2;
        t2 = new A.SassMap0(H.ConstantMap_ConstantMap$from(t1.result, t2, t2));
        t1 = t2;
      } else
        t1 = map2;
      return t1;
    },
    _function9($name, $arguments, callback) {
      return Q.BuiltInCallable$function0($name, $arguments, callback, "sass:map");
    },
    _get_closure0: function _get_closure0() {
    },
    _set_closure1: function _set_closure1() {
    },
    _set__closure2: function _set__closure2(t0) {
      this.$arguments = t0;
    },
    _set_closure2: function _set_closure2() {
    },
    _set__closure1: function _set__closure1(t0) {
      this.args = t0;
    },
    _merge_closure1: function _merge_closure1() {
    },
    _merge_closure2: function _merge_closure2() {
    },
    _merge__closure0: function _merge__closure0(t0) {
      this.map2 = t0;
    },
    _deepMerge_closure0: function _deepMerge_closure0() {
    },
    _deepRemove_closure0: function _deepRemove_closure0() {
    },
    _deepRemove__closure0: function _deepRemove__closure0(t0) {
      this.keys = t0;
    },
    _remove_closure1: function _remove_closure1() {
    },
    _remove_closure2: function _remove_closure2() {
    },
    _keys_closure0: function _keys_closure0() {
    },
    _values_closure0: function _values_closure0() {
    },
    _hasKey_closure0: function _hasKey_closure0() {
    },
    _modify__modifyNestedMap0: function _modify__modifyNestedMap0(t0, t1, t2) {
      this.keyIterator = t0;
      this.modify = t1;
      this.addNesting = t2;
    },
    _deepMergeImpl__ensureMutable0: function _deepMergeImpl__ensureMutable0(t0) {
      this._box_0 = t0;
    },
    _deepMergeImpl_closure0: function _deepMergeImpl_closure0(t0, t1) {
      this._box_0 = t0;
      this._ensureMutable = t1;
    },
    _NodeSassMap: function _NodeSassMap() {
    },
    legacyMapClass_closure: function legacyMapClass_closure() {
    },
    legacyMapClass__closure: function legacyMapClass__closure() {
    },
    legacyMapClass__closure0: function legacyMapClass__closure0() {
    },
    legacyMapClass_closure0: function legacyMapClass_closure0() {
    },
    legacyMapClass_closure1: function legacyMapClass_closure1() {
    },
    legacyMapClass_closure2: function legacyMapClass_closure2() {
    },
    legacyMapClass_closure3: function legacyMapClass_closure3() {
    },
    legacyMapClass_closure4: function legacyMapClass_closure4() {
    },
    SassMap0: function SassMap0(t0) {
      this._map0$_contents = t0;
    },
    SassMap_asList_closure0: function SassMap_asList_closure0(t0) {
      this.result = t0;
    },
    MergedExtension_merge0(left, right) {
      var t4, t5, t6,
        t1 = left.extender,
        t2 = t1.selector,
        t3 = C.C_ListEquality.equals$2(0, t2.components, right.extender.selector.components);
      if (!t3 || !left.target.$eq(0, right.target))
        throw H.wrapException(P.ArgumentError$(left.toString$0(0) + " and " + right.toString$0(0) + " aren't the same extension.", null));
      t3 = left.mediaContext;
      t4 = t3 == null;
      if (!t4) {
        t5 = right.mediaContext;
        t5 = t5 != null && !C.C_ListEquality.equals$2(0, t3, t5);
      } else
        t5 = false;
      if (t5)
        throw H.wrapException(E.SassException$0("From " + left.span.message$1(0, "") + string$.x0aYou_m, right.span));
      if (right.isOptional && right.mediaContext == null)
        return left;
      if (left.isOptional && t4)
        return right;
      t5 = left.target;
      t6 = left.span;
      if (t4)
        t3 = right.mediaContext;
      t2.get$maxSpecificity();
      t1 = new S.Extender0(t2, false, t1.span);
      return t1._extension$_extension = new A.MergedExtension0(left, right, t1, t5, t3, true, t6);
    },
    MergedExtension0: function MergedExtension0(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.left = t0;
      _.right = t1;
      _.extender = t2;
      _.target = t3;
      _.mediaContext = t4;
      _.isOptional = t5;
      _.span = t6;
    },
    _IterableExtension__search0(_this, callback) {
      var t1, value;
      for (t1 = J.get$iterator$ax(_this); t1.moveNext$0();) {
        value = callback.call$1(t1.get$current(t1));
        if (value != null)
          return value;
      }
    },
    StatementSearchVisitor0: function StatementSearchVisitor0() {
    },
    StatementSearchVisitor_visitIfRule_closure1: function StatementSearchVisitor_visitIfRule_closure1(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure2: function StatementSearchVisitor_visitIfRule__closure2(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule_closure2: function StatementSearchVisitor_visitIfRule_closure2(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitIfRule__closure1: function StatementSearchVisitor_visitIfRule__closure1(t0) {
      this.$this = t0;
    },
    StatementSearchVisitor_visitChildren_closure0: function StatementSearchVisitor_visitChildren_closure0(t0) {
      this.$this = t0;
    },
    IterableNullableExtension_whereNotNull(_this, $T) {
      return A.IterableNullableExtension_whereNotNull$body(_this, $T, $T);
    },
    IterableNullableExtension_whereNotNull$body($async$_this, $async$$T, $async$type) {
      return P._makeSyncStarIterable(function() {
        var _this = $async$_this,
          $T = $async$$T;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, element;
        return function $async$IterableNullableExtension_whereNotNull($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = _this.get$iterator(_this);
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                element = t1.get$current(t1);
                $async$goto = element != null ? 4 : 5;
                break;
              case 4:
                // then
                $async$goto = 6;
                return element;
              case 6:
                // after yield
              case 5:
                // join
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    IterableIntegerExtension_get_sum(_this) {
      var t1, t2, result;
      for (t1 = new H.MappedIterator(J.get$iterator$ax(_this.__internal$_iterable), _this._f), t2 = H._instanceType(t1)._rest[1], result = 0; t1.moveNext$0();)
        result += t2._as(t1.__internal$_current);
      return result;
    },
    _combine(hash, value) {
      hash = hash + value & 536870911;
      hash = hash + ((hash & 524287) << 10) & 536870911;
      return hash ^ hash >>> 6;
    },
    _finish(hash) {
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >>> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    }
  },
  B = {ReplAdapter: function ReplAdapter(t0) {
      this.repl = t0;
      this.rl = null;
    }, ReplAdapter_runAsync_closure: function ReplAdapter_runAsync_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.rl = t2;
      _.runController = t3;
    }, ReplAdapter_runAsync__closure: function ReplAdapter_runAsync__closure(t0) {
      this.lineController = t0;
    }, Stdin: function Stdin() {
    }, Stdout: function Stdout() {
    }, ReadlineModule: function ReadlineModule() {
    }, ReadlineOptions: function ReadlineOptions() {
    }, ReadlineInterface: function ReadlineInterface() {
    }, InternalStyle: function InternalStyle() {
    }, ModifiableCssNode: function ModifiableCssNode() {
    }, ModifiableCssParentNode: function ModifiableCssParentNode() {
    },
    ModifiableCssSupportsRule$(condition, span) {
      var t1 = H._setArrayType([], type$.JSArray_ModifiableCssNode);
      return new B.ModifiableCssSupportsRule(condition, span, new P.UnmodifiableListView(t1, type$.UnmodifiableListView_ModifiableCssNode), t1);
    },
    ModifiableCssSupportsRule: function ModifiableCssSupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _._children = t3;
      _._indexInParent = _._parent = null;
      _.isGroupEnd = false;
    },
    CssNode: function CssNode() {
    },
    CssParentNode: function CssParentNode() {
    },
    AstNode: function AstNode() {
    },
    _FakeAstNode: function _FakeAstNode(t0) {
      this._callback = t0;
    },
    ArgumentDeclaration_ArgumentDeclaration$parse(contents, url) {
      return L.ScssParser$(contents, null, url).parseArgumentDeclaration$0();
    },
    ArgumentDeclaration: function ArgumentDeclaration(t0, t1, t2) {
      this.$arguments = t0;
      this.restArgument = t1;
      this.span = t2;
    },
    ArgumentDeclaration_verify_closure: function ArgumentDeclaration_verify_closure() {
    },
    ArgumentDeclaration_verify_closure0: function ArgumentDeclaration_verify_closure0() {
    },
    DynamicImport: function DynamicImport(t0, t1) {
      this.urlString = t0;
      this.span = t1;
    },
    ForRule$(variable, from, to, children, span, exclusive) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new B.ForRule(variable, from, to, exclusive, span, t1, t2);
    },
    ForRule: function ForRule(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.variable = t0;
      _.from = t1;
      _.to = t2;
      _.isExclusive = t3;
      _.span = t4;
      _.children = t5;
      _.hasDeclarations = t6;
    },
    ImportRule: function ImportRule(t0, t1) {
      this.imports = t0;
      this.span = t1;
    },
    ReturnRule: function ReturnRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    SilentComment: function SilentComment(t0, t1) {
      this.text = t0;
      this.span = t1;
    },
    SupportsRule$(condition, children, span) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
      return new B.SupportsRule(condition, span, t1, t2);
    },
    SupportsRule: function SupportsRule(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    ExecutableOptions__separator(text) {
      var t1 = $.$get$ExecutableOptions__separatorBar(),
        t2 = C.JSString_methods.$mul(t1, 3) + " ";
      t2 = t2 + (J.$eq$(self.process.stdout.isTTY, true) ? "\x1b[1m" : "") + text;
      return t2 + (J.$eq$(self.process.stdout.isTTY, true) ? "\x1b[0m" : "") + " " + C.JSString_methods.$mul(t1, 35 - text.length);
    },
    ExecutableOptions__fail(message) {
      return H.throwExpression(B.UsageException$(message));
    },
    ExecutableOptions_ExecutableOptions$parse(args) {
      var options, error, t1, exception;
      try {
        t1 = G.Parser$(null, $.$get$ExecutableOptions__parser(), P.ListQueue_ListQueue$of(args, type$.String), null, null).parse$0();
        if (t1.wasParsed$1("poll") && !H._asBool(t1.$index(0, "watch")))
          B.ExecutableOptions__fail("--poll may not be passed without --watch.");
        options = new B.ExecutableOptions(t1);
        if (H._asBool(options._options.$index(0, "help")))
          B.ExecutableOptions__fail("Compile Sass to CSS.");
        return options;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (type$.FormatException._is(t1)) {
          error = t1;
          B.ExecutableOptions__fail(J.get$message$x(error));
        } else
          throw exception;
      }
    },
    UsageException$(message) {
      return new B.UsageException(message);
    },
    ExecutableOptions: function ExecutableOptions(t0) {
      var _ = this;
      _._options = t0;
      _.__ExecutableOptions__sourceDirectoriesToDestinations = _._sourcesToDestinations = _.__ExecutableOptions_interactive = null;
    },
    ExecutableOptions__parser_closure: function ExecutableOptions__parser_closure() {
    },
    ExecutableOptions_interactive_closure: function ExecutableOptions_interactive_closure(t0) {
      this.$this = t0;
    },
    ExecutableOptions_emitErrorCss_closure: function ExecutableOptions_emitErrorCss_closure() {
    },
    UsageException: function UsageException(t0) {
      this.message = t0;
    },
    AsyncImporter: function AsyncImporter() {
    },
    fromImport() {
      var t1 = H._asBoolQ($.Zone__current.$index(0, C.Symbol__inImportRule));
      return t1 === true;
    },
    resolveImportPath(path) {
      var t1,
        extension = X.ParsedPath_ParsedPath$parse(path, $.$get$context().style)._splitExtension$1(1)[1];
      if (extension === ".sass" || extension === ".scss" || extension === ".css") {
        t1 = B.fromImport() ? new B.resolveImportPath_closure(path, extension).call$0() : null;
        return t1 == null ? B._exactlyOne(B._tryPath(path)) : t1;
      }
      t1 = B.fromImport() ? new B.resolveImportPath_closure0(path).call$0() : null;
      if (t1 == null)
        t1 = B._exactlyOne(B._tryPathWithExtensions(path));
      return t1 == null ? B._tryPathAsDirectory(path) : t1;
    },
    _tryPathWithExtensions(path) {
      var result = B._tryPath(path + ".sass");
      C.JSArray_methods.addAll$1(result, B._tryPath(path + ".scss"));
      return result.length !== 0 ? result : B._tryPath(path + ".css");
    },
    _tryPath(path) {
      var t1 = $.$get$context(),
        partial = D.join(t1.dirname$1(path), "_" + X.ParsedPath_ParsedPath$parse(path, t1.style).get$basename(), null);
      t1 = H._setArrayType([], type$.JSArray_String);
      if (B.fileExists(partial))
        t1.push(partial);
      if (B.fileExists(path))
        t1.push(path);
      return t1;
    },
    _tryPathAsDirectory(path) {
      var t1;
      if (!B.dirExists(path))
        return null;
      t1 = B.fromImport() ? new B._tryPathAsDirectory_closure(path).call$0() : null;
      return t1 == null ? B._exactlyOne(B._tryPathWithExtensions(D.join(path, "index", null))) : t1;
    },
    _exactlyOne(paths) {
      var t1 = paths.length;
      if (t1 === 0)
        return null;
      if (t1 === 1)
        return C.JSArray_methods.get$first(paths);
      throw H.wrapException(string$.It_s_n + C.JSArray_methods.map$1$1(paths, new B._exactlyOne_closure(), type$.String).join$1(0, "\n"));
    },
    resolveImportPath_closure: function resolveImportPath_closure(t0, t1) {
      this.path = t0;
      this.extension = t1;
    },
    resolveImportPath_closure0: function resolveImportPath_closure0(t0) {
      this.path = t0;
    },
    _tryPathAsDirectory_closure: function _tryPathAsDirectory_closure(t0) {
      this.path = t0;
    },
    _exactlyOne_closure: function _exactlyOne_closure() {
    },
    readFile(path) {
      var sourceFile, t1, i,
        contents = H._asString(B._readFile(path, "utf8"));
      if (!C.JSString_methods.contains$1(contents, "\ufffd"))
        return contents;
      sourceFile = Y.SourceFile$fromString(contents, $.$get$context().toUri$1(path));
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$("Invalid UTF-8.", Y.FileLocation$_(sourceFile, i).pointSpan$0()));
      }
      return contents;
    },
    _readFile(path, encoding) {
      return B._systemErrorToFileSystemException(new B._readFile_closure(path, encoding));
    },
    writeFile(path, contents) {
      return B._systemErrorToFileSystemException(new B.writeFile_closure(path, contents));
    },
    deleteFile(path) {
      return B._systemErrorToFileSystemException(new B.deleteFile_closure(path));
    },
    readStdin() {
      return B.readStdin$body();
    },
    readStdin$body() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue, sink, t1, t2, completer;
      var $async$readStdin = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = new P._Future($.Zone__current, type$._Future_String);
              completer = new P._AsyncCompleter(t2, type$._AsyncCompleter_String);
              t1.contents = null;
              sink = new P._StringCallbackSink(new B.readStdin_closure(t1, completer), new P.StringBuffer("")).asUtf8Sink$1(false);
              J.on$2$x(J.get$stdin$x(self.process), "data", P.allowInterop(new B.readStdin_closure0(sink)));
              J.on$2$x(J.get$stdin$x(self.process), "end", P.allowInterop(new B.readStdin_closure1(sink)));
              J.on$2$x(J.get$stdin$x(self.process), "error", P.allowInterop(new B.readStdin_closure2(completer)));
              $async$returnValue = t2;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$readStdin, $async$completer);
    },
    fileExists(path) {
      return B._systemErrorToFileSystemException(new B.fileExists_closure(path));
    },
    dirExists(path) {
      return B._systemErrorToFileSystemException(new B.dirExists_closure(path));
    },
    ensureDir(path) {
      return B._systemErrorToFileSystemException(new B.ensureDir_closure(path));
    },
    listDir(path, recursive) {
      return B._systemErrorToFileSystemException(new B.listDir_closure(recursive, path));
    },
    modificationTime(path) {
      return B._systemErrorToFileSystemException(new B.modificationTime_closure(path));
    },
    _systemErrorToFileSystemException(callback) {
      var error, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        if (!type$.JsSystemError._is(error))
          throw exception;
        t1 = error;
        t2 = J.getInterceptor$x(t1);
        throw H.wrapException(new B.FileSystemException(J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.get$length$asx(t2.get$message(t1)) - (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length), J.get$path$x(error)));
      }
    },
    isWindows() {
      return J.$eq$(J.get$platform$x(self.process), "win32");
    },
    watchDir(path, poll) {
      var t2, t3, t1 = {},
        watcher = J.watch$2$x(self.chokidar, path, {disableGlobbing: true, usePolling: poll});
      t1.controller = null;
      t2 = J.getInterceptor$x(watcher);
      t2.on$2(watcher, "add", P.allowInterop(new B.watchDir_closure(t1)));
      t2.on$2(watcher, "change", P.allowInterop(new B.watchDir_closure0(t1)));
      t2.on$2(watcher, "unlink", P.allowInterop(new B.watchDir_closure1(t1)));
      t2.on$2(watcher, "error", P.allowInterop(new B.watchDir_closure2(t1)));
      t3 = new P._Future($.Zone__current, type$._Future_Stream_WatchEvent);
      t2.on$2(watcher, "ready", P.allowInterop(new B.watchDir_closure3(t1, watcher, new P._AsyncCompleter(t3, type$._AsyncCompleter_Stream_WatchEvent))));
      return t3;
    },
    FileSystemException: function FileSystemException(t0, t1) {
      this.message = t0;
      this.path = t1;
    },
    Stderr: function Stderr(t0) {
      this._stderr = t0;
    },
    _readFile_closure: function _readFile_closure(t0, t1) {
      this.path = t0;
      this.encoding = t1;
    },
    writeFile_closure: function writeFile_closure(t0, t1) {
      this.path = t0;
      this.contents = t1;
    },
    deleteFile_closure: function deleteFile_closure(t0) {
      this.path = t0;
    },
    readStdin_closure: function readStdin_closure(t0, t1) {
      this._box_0 = t0;
      this.completer = t1;
    },
    readStdin_closure0: function readStdin_closure0(t0) {
      this.sink = t0;
    },
    readStdin_closure1: function readStdin_closure1(t0) {
      this.sink = t0;
    },
    readStdin_closure2: function readStdin_closure2(t0) {
      this.completer = t0;
    },
    fileExists_closure: function fileExists_closure(t0) {
      this.path = t0;
    },
    dirExists_closure: function dirExists_closure(t0) {
      this.path = t0;
    },
    ensureDir_closure: function ensureDir_closure(t0) {
      this.path = t0;
    },
    listDir_closure: function listDir_closure(t0, t1) {
      this.recursive = t0;
      this.path = t1;
    },
    listDir__closure: function listDir__closure(t0) {
      this.path = t0;
    },
    listDir__closure0: function listDir__closure0() {
    },
    listDir_closure_list: function listDir_closure_list() {
    },
    listDir__list_closure: function listDir__list_closure(t0, t1) {
      this.parent = t0;
      this.list = t1;
    },
    modificationTime_closure: function modificationTime_closure(t0) {
      this.path = t0;
    },
    watchDir_closure: function watchDir_closure(t0) {
      this._box_0 = t0;
    },
    watchDir_closure0: function watchDir_closure0(t0) {
      this._box_0 = t0;
    },
    watchDir_closure1: function watchDir_closure1(t0) {
      this._box_0 = t0;
    },
    watchDir_closure2: function watchDir_closure2(t0) {
      this._box_0 = t0;
    },
    watchDir_closure3: function watchDir_closure3(t0, t1, t2) {
      this._box_0 = t0;
      this.watcher = t1;
      this.completer = t2;
    },
    watchDir__closure: function watchDir__closure(t0) {
      this.watcher = t0;
    },
    ShadowedModuleView_ifNecessary(inner, functions, mixins, variables, $T) {
      return B.ShadowedModuleView__needsBlocklist(inner.get$variables(), variables) || B.ShadowedModuleView__needsBlocklist(inner.get$functions(inner), functions) || B.ShadowedModuleView__needsBlocklist(inner.get$mixins(), mixins) ? new B.ShadowedModuleView(inner, B.ShadowedModuleView__shadowedMap(inner.get$variables(), variables, type$.Value), B.ShadowedModuleView__shadowedMap(inner.get$variableNodes(), variables, type$.AstNode), B.ShadowedModuleView__shadowedMap(inner.get$functions(inner), functions, $T), B.ShadowedModuleView__shadowedMap(inner.get$mixins(), mixins, $T), $T._eval$1("ShadowedModuleView<0>")) : null;
    },
    ShadowedModuleView__shadowedMap(map, blocklist, $V) {
      var t1 = B.ShadowedModuleView__needsBlocklist(map, blocklist);
      return !t1 ? map : K.LimitedMapView$blocklist(map, blocklist, type$.String, $V);
    },
    ShadowedModuleView__needsBlocklist(map, blocklist) {
      var t1 = map.get$isNotEmpty(map) && blocklist.any$1(0, map.get$containsKey());
      return t1;
    },
    ShadowedModuleView: function ShadowedModuleView(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._shadowed_view$_inner = t0;
      _.variables = t1;
      _.variableNodes = t2;
      _.functions = t3;
      _.mixins = t4;
      _.$ti = t5;
    },
    _PropertyDescriptor: function _PropertyDescriptor() {
    },
    toSentence(iter, conjunction) {
      var t1 = iter.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1);
      if (t2.get$length(t1) === 1)
        return J.toString$0$(iter._f.call$1(t2.get$first(t1)));
      return H.TakeIterable_TakeIterable(iter, t2.get$length(t1) - 1, H._instanceType(iter)._eval$1("Iterable.E")).join$1(0, ", ") + (" " + conjunction + " " + H.S(iter._f.call$1(t2.get$last(t1))));
    },
    indent(string, indentation) {
      return new H.MappedListIterable(H._setArrayType(string.split("\n"), type$.JSArray_String), new B.indent_closure(indentation), type$.MappedListIterable_String_String).join$1(0, "\n");
    },
    pluralize($name, number, plural) {
      if (number === 1)
        return $name;
      if (plural != null)
        return plural;
      return $name + "s";
    },
    trimAscii(string, excludeEscape) {
      var t1,
        start = B._firstNonWhitespace(string);
      if (start == null)
        t1 = "";
      else {
        t1 = B._lastNonWhitespace(string, true);
        t1.toString;
        t1 = C.JSString_methods.substring$2(string, start, t1 + 1);
      }
      return t1;
    },
    trimAsciiRight(string, excludeEscape) {
      var end = B._lastNonWhitespace(string, excludeEscape);
      return end == null ? "" : C.JSString_methods.substring$2(string, 0, end + 1);
    },
    _firstNonWhitespace(string) {
      var t1, i, t2;
      for (t1 = string.length, i = 0; i < t1; ++i) {
        t2 = C.JSString_methods._codeUnitAt$1(string, i);
        if (!(t2 === 32 || t2 === 9 || t2 === 10 || t2 === 13 || t2 === 12))
          return i;
      }
      return null;
    },
    _lastNonWhitespace(string, excludeEscape) {
      var t1, i, codeUnit;
      for (t1 = string.length, i = t1 - 1; i >= 0; --i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(string, i);
        if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
          if (excludeEscape && i !== 0 && i !== t1 && codeUnit === 92)
            return i + 1;
          else
            return i;
      }
      return null;
    },
    isPublic(member) {
      var start = C.JSString_methods._codeUnitAt$1(member, 0);
      return start !== 45 && start !== 95;
    },
    flattenVertically(iterable, $T) {
      var result,
        t1 = iterable.$ti._eval$1("@<ListIterable.E>")._bind$1($T._eval$1("QueueList<0>"))._eval$1("MappedListIterable<1,2>"),
        queues = P.List_List$of(new H.MappedListIterable(iterable, new B.flattenVertically_closure($T), t1), true, t1._eval$1("ListIterable.E"));
      if (queues.length === 1)
        return C.JSArray_methods.get$first(queues);
      result = H._setArrayType([], $T._eval$1("JSArray<0>"));
      for (; queues.length !== 0;) {
        if (!!queues.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeWhere"));
        C.JSArray_methods._removeWhere$2(queues, new B.flattenVertically_closure0(result, $T), true);
      }
      return result;
    },
    firstOrNull(iterable) {
      var iterator = J.get$iterator$ax(iterable);
      return iterator.moveNext$0() ? iterator.get$current(iterator) : null;
    },
    codepointIndexToCodeUnitIndex(string, codepointIndex) {
      var codeUnitIndex, i, codeUnitIndex0;
      for (codeUnitIndex = 0, i = 0; i < codepointIndex; ++i) {
        codeUnitIndex0 = codeUnitIndex + 1;
        codeUnitIndex = C.JSString_methods._codeUnitAt$1(string, codeUnitIndex) >>> 10 === 54 ? codeUnitIndex0 + 1 : codeUnitIndex0;
      }
      return codeUnitIndex;
    },
    codeUnitIndexToCodepointIndex(string, codeUnitIndex) {
      var codepointIndex, i;
      for (codepointIndex = 0, i = 0; i < codeUnitIndex; i = (C.JSString_methods._codeUnitAt$1(string, i) >>> 10 === 54 ? i + 1 : i) + 1)
        ++codepointIndex;
      return codepointIndex;
    },
    frameForSpan(span, member, url) {
      var t2, t3, t4,
        t1 = url == null ? span.file.url : url;
      if (t1 == null)
        t1 = $.$get$_noSourceUrl();
      t2 = span.file;
      t3 = span._file$_start;
      t4 = Y.FileLocation$_(t2, t3);
      t4 = t4.file.getLine$1(t4.offset);
      t3 = Y.FileLocation$_(t2, t3);
      return new A.Frame(t1, t4 + 1, t3.file.getColumn$1(t3.offset) + 1, member);
    },
    declarationName(span) {
      var text = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, span._file$_start, span._end), 0, null);
      return B.trimAsciiRight(C.JSString_methods.substring$2(text, 0, C.JSString_methods.indexOf$1(text, ":")), false);
    },
    unvendor($name) {
      var i,
        t1 = $name.length;
      if (t1 < 2)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 0) !== 45)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 1) === 45)
        return $name;
      for (i = 2; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1($name, i) === 45)
          return C.JSString_methods.substring$1($name, i + 1);
      return $name;
    },
    equalsIgnoreCase(string1, string2) {
      var t1, i;
      if (string1 === string2)
        return true;
      if (string1 == null || false)
        return false;
      t1 = string1.length;
      if (t1 !== string2.length)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(C.JSString_methods._codeUnitAt$1(string1, i), C.JSString_methods._codeUnitAt$1(string2, i)))
          return false;
      return true;
    },
    startsWithIgnoreCase(string, prefix) {
      var i,
        t1 = prefix.length;
      if (string.length < t1)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase(C.JSString_methods._codeUnitAt$1(string, i), C.JSString_methods._codeUnitAt$1(prefix, i)))
          return false;
      return true;
    },
    mapInPlace(list, $function) {
      var i;
      for (i = 0; i < list.length; ++i)
        list[i] = $function.call$1(list[i]);
    },
    longestCommonSubsequence(list1, list2, select, $T) {
      var t1, _length, lengths, t2, t3, _i, selections, i, i0, j, selection, j0;
      if (select == null)
        select = new B.longestCommonSubsequence_closure($T);
      t1 = J.getInterceptor$asx(list1);
      _length = t1.get$length(list1) + 1;
      lengths = J.JSArray_JSArray$allocateFixed(_length, type$.List_int);
      for (t2 = J.getInterceptor$asx(list2), t3 = type$.int, _i = 0; _i < _length; ++_i)
        lengths[_i] = P.List_List$filled(t2.get$length(list2) + 1, 0, false, t3);
      _length = t1.get$length(list1);
      selections = J.JSArray_JSArray$allocateFixed(_length, $T._eval$1("List<0?>"));
      for (t3 = $T._eval$1("0?"), _i = 0; _i < _length; ++_i)
        selections[_i] = P.List_List$filled(t2.get$length(list2), null, false, t3);
      for (i = 0; i < t1.get$length(list1); i = i0)
        for (i0 = i + 1, j = 0; j < t2.get$length(list2); j = j0) {
          selection = select.call$2(t1.$index(list1, i), t2.$index(list2, j));
          selections[i][j] = selection;
          t3 = lengths[i0];
          j0 = j + 1;
          t3[j0] = selection == null ? Math.max(t3[j], lengths[i][j0]) : lengths[i][j] + 1;
        }
      return new B.longestCommonSubsequence_backtrack(selections, lengths, $T).call$2(t1.get$length(list1) - 1, t2.get$length(list2) - 1);
    },
    removeFirstWhere(list, test, orElse) {
      var i;
      for (i = 0; i < list.length; ++i) {
        if (!test.call$1(list[i]))
          continue;
        C.JSArray_methods.removeAt$1(list, i);
        return;
      }
      orElse.call$0();
    },
    mapAddAll2(destination, source, K1, K2, $V) {
      source.forEach$1(0, new B.mapAddAll2_closure(destination, K1, K2, $V));
    },
    setAll(map, keys, value) {
      var t1;
      for (t1 = J.get$iterator$ax(keys); t1.moveNext$0();)
        map.$indexSet(0, t1.get$current(t1), value);
    },
    rotateSlice(list, start, end) {
      var i, next,
        element = list.$index(0, end - 1);
      for (i = start; i < end; ++i, element = next) {
        next = list.$index(0, i);
        list.$indexSet(0, i, element);
      }
    },
    mapAsync(iterable, callback, $E, $F) {
      return B.mapAsync$body(iterable, callback, $E, $F, $F._eval$1("Iterable<0>"));
    },
    mapAsync$body(iterable, callback, $E, $F, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t2, _i, t1, $async$temp1;
      var $async$mapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H._setArrayType([], $F._eval$1("JSArray<0>"));
              t2 = iterable.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = t1;
              $async$goto = 6;
              return P._asyncAwait(callback.call$1(iterable[_i]), $async$mapAsync);
            case 6:
              // returning from await.
              $async$temp1.push($async$result);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapAsync, $async$completer);
    },
    putIfAbsentAsync(map, key, ifAbsent, $K, $V) {
      return B.putIfAbsentAsync$body(map, key, ifAbsent, $K, $V, $V);
    },
    putIfAbsentAsync$body(map, key, ifAbsent, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, value;
      var $async$putIfAbsentAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (map.containsKey$1(key)) {
                $async$returnValue = $V._as(map.$index(0, key));
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(ifAbsent.call$0(), $async$putIfAbsentAsync);
            case 3:
              // returning from await.
              value = $async$result;
              map.$indexSet(0, key, value);
              $async$returnValue = value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$putIfAbsentAsync, $async$completer);
    },
    copyMapOfMap(map, K1, K2, $V) {
      var t2, t3, t4, t5,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(K1, K2._eval$1("@<0>")._bind$1($V)._eval$1("Map<1,2>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t4 = t3.key;
        t3 = t3.value;
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, K2, $V);
        t5.addAll$1(0, t3);
        t1.$indexSet(0, t4, t5);
      }
      return t1;
    },
    copyMapOfList(map, $K, $E) {
      var t2, t3,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty($K, $E._eval$1("List<0>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t1.$indexSet(0, t3.key, J.toList$0$ax(t3.value));
      }
      return t1;
    },
    consumeEscapedCharacter(scanner) {
      var first, value, i, next, t1;
      scanner.expectChar$1(92);
      first = scanner.peekChar$0();
      if (first == null)
        return 65533;
      else if (first === 10 || first === 13 || first === 12)
        scanner.error$1(0, "Expected escape sequence.");
      else if (T.isHex(first)) {
        for (value = 0, i = 0; i < 6; ++i) {
          next = scanner.peekChar$0();
          if (next == null || !T.isHex(next))
            break;
          value = (value << 4 >>> 0) + T.asHex(scanner.readChar$0());
        }
        t1 = scanner.peekChar$0();
        if (t1 === 32 || t1 === 9 || t1 === 10 || t1 === 13 || t1 === 12)
          scanner.readChar$0();
        if (value !== 0)
          t1 = value >= 55296 && value <= 57343 || value >= 1114111;
        else
          t1 = true;
        if (t1)
          return 65533;
        else
          return value;
      } else
        return scanner.readChar$0();
    },
    throwWithTrace(error, trace) {
      B.attachTrace(error, trace);
      throw H.wrapException(error);
    },
    attachTrace(error, trace) {
      var t1;
      if (trace.toString$0(0).length === 0)
        return;
      t1 = $.$get$_traces();
      P.Expando__checkType(error);
      t1 = t1._jsWeakMap;
      if (t1.get(error) == null)
        t1.set(error, trace);
    },
    getTrace(error) {
      var t1;
      if (typeof error == "string" || typeof error == "number" || H._isBool(error))
        t1 = null;
      else {
        t1 = $.$get$_traces();
        P.Expando__checkType(error);
        t1 = t1._jsWeakMap.get(error);
      }
      return t1;
    },
    indent_closure: function indent_closure(t0) {
      this.indentation = t0;
    },
    flattenVertically_closure: function flattenVertically_closure(t0) {
      this.T = t0;
    },
    flattenVertically_closure0: function flattenVertically_closure0(t0, t1) {
      this.result = t0;
      this.T = t1;
    },
    longestCommonSubsequence_closure: function longestCommonSubsequence_closure(t0) {
      this.T = t0;
    },
    longestCommonSubsequence_backtrack: function longestCommonSubsequence_backtrack(t0, t1, t2) {
      this.selections = t0;
      this.lengths = t1;
      this.T = t2;
    },
    mapAddAll2_closure: function mapAddAll2_closure(t0, t1, t2, t3) {
      var _ = this;
      _.destination = t0;
      _.K1 = t1;
      _.K2 = t2;
      _.V = t3;
    },
    ArgumentDeclaration_ArgumentDeclaration$parse0(contents, url) {
      return L.ScssParser$0(contents, null, url).parseArgumentDeclaration$0();
    },
    ArgumentDeclaration0: function ArgumentDeclaration0(t0, t1, t2) {
      this.$arguments = t0;
      this.restArgument = t1;
      this.span = t2;
    },
    ArgumentDeclaration_verify_closure1: function ArgumentDeclaration_verify_closure1() {
    },
    ArgumentDeclaration_verify_closure2: function ArgumentDeclaration_verify_closure2() {
    },
    AsyncImporter0: function AsyncImporter0() {
    },
    DynamicImport0: function DynamicImport0(t0, t1) {
      this.urlString = t0;
      this.span = t1;
    },
    ForRule$0(variable, from, to, children, span, exclusive) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement_2),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure0());
      return new B.ForRule0(variable, from, to, exclusive, span, t1, t2);
    },
    ForRule0: function ForRule0(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.variable = t0;
      _.from = t1;
      _.to = t2;
      _.isExclusive = t3;
      _.span = t4;
      _.children = t5;
      _.hasDeclarations = t6;
    },
    ImportRule0: function ImportRule0(t0, t1) {
      this.imports = t0;
      this.span = t1;
    },
    AstNode0: function AstNode0() {
    },
    _FakeAstNode0: function _FakeAstNode0(t0) {
      this._node2$_callback = t0;
    },
    CssNode0: function CssNode0() {
    },
    CssParentNode0: function CssParentNode0() {
    },
    readFile0(path) {
      var sourceFile, t1, i,
        contents = H._asString(B._readFile0(path, "utf8"));
      if (!C.JSString_methods.contains$1(contents, "\ufffd"))
        return contents;
      sourceFile = Y.SourceFile$fromString(contents, $.$get$context().toUri$1(path));
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$0("Invalid UTF-8.", Y.FileLocation$_(sourceFile, i).pointSpan$0()));
      }
      return contents;
    },
    _readFile0(path, encoding) {
      return B._systemErrorToFileSystemException0(new B._readFile_closure0(path, encoding));
    },
    fileExists0(path) {
      return B._systemErrorToFileSystemException0(new B.fileExists_closure0(path));
    },
    dirExists0(path) {
      return B._systemErrorToFileSystemException0(new B.dirExists_closure0(path));
    },
    listDir0(path) {
      return B._systemErrorToFileSystemException0(new B.listDir_closure0(false, path));
    },
    _systemErrorToFileSystemException0(callback) {
      var error, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        if (!type$.JsSystemError._is(error))
          throw exception;
        t1 = error;
        t2 = J.getInterceptor$x(t1);
        throw H.wrapException(new B.FileSystemException0(J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.get$length$asx(t2.get$message(t1)) - (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length), J.get$path$x(error)));
      }
    },
    FileSystemException0: function FileSystemException0(t0, t1) {
      this.message = t0;
      this.path = t1;
    },
    Stderr0: function Stderr0(t0) {
      this._node0$_stderr = t0;
    },
    _readFile_closure0: function _readFile_closure0(t0, t1) {
      this.path = t0;
      this.encoding = t1;
    },
    fileExists_closure0: function fileExists_closure0(t0) {
      this.path = t0;
    },
    dirExists_closure0: function dirExists_closure0(t0) {
      this.path = t0;
    },
    listDir_closure0: function listDir_closure0(t0, t1) {
      this.recursive = t0;
      this.path = t1;
    },
    listDir__closure1: function listDir__closure1(t0) {
      this.path = t0;
    },
    listDir__closure2: function listDir__closure2() {
    },
    listDir_closure_list0: function listDir_closure_list0() {
    },
    listDir__list_closure0: function listDir__list_closure0(t0, t1) {
      this.parent = t0;
      this.list = t1;
    },
    ModifiableCssNode0: function ModifiableCssNode0() {
    },
    ModifiableCssParentNode0: function ModifiableCssParentNode0() {
    },
    ReturnRule0: function ReturnRule0(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    ShadowedModuleView_ifNecessary0(inner, functions, mixins, variables, $T) {
      return B.ShadowedModuleView__needsBlocklist0(inner.get$variables(), variables) || B.ShadowedModuleView__needsBlocklist0(inner.get$functions(inner), functions) || B.ShadowedModuleView__needsBlocklist0(inner.get$mixins(), mixins) ? new B.ShadowedModuleView0(inner, B.ShadowedModuleView__shadowedMap0(inner.get$variables(), variables, type$.Value_2), B.ShadowedModuleView__shadowedMap0(inner.get$variableNodes(), variables, type$.AstNode_2), B.ShadowedModuleView__shadowedMap0(inner.get$functions(inner), functions, $T), B.ShadowedModuleView__shadowedMap0(inner.get$mixins(), mixins, $T), $T._eval$1("ShadowedModuleView0<0>")) : null;
    },
    ShadowedModuleView__shadowedMap0(map, blocklist, $V) {
      var t1 = B.ShadowedModuleView__needsBlocklist0(map, blocklist);
      return !t1 ? map : K.LimitedMapView$blocklist0(map, blocklist, type$.String, $V);
    },
    ShadowedModuleView__needsBlocklist0(map, blocklist) {
      var t1 = map.get$isNotEmpty(map) && blocklist.any$1(0, map.get$containsKey());
      return t1;
    },
    ShadowedModuleView0: function ShadowedModuleView0(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._shadowed_view0$_inner = t0;
      _.variables = t1;
      _.variableNodes = t2;
      _.functions = t3;
      _.mixins = t4;
      _.$ti = t5;
    },
    SilentComment0: function SilentComment0(t0, t1) {
      this.text = t0;
      this.span = t1;
    },
    ModifiableCssSupportsRule$0(condition, span) {
      var t1 = H._setArrayType([], type$.JSArray_ModifiableCssNode_2);
      return new B.ModifiableCssSupportsRule0(condition, span, new P.UnmodifiableListView(t1, type$.UnmodifiableListView_ModifiableCssNode_2), t1);
    },
    ModifiableCssSupportsRule0: function ModifiableCssSupportsRule0(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _._node1$_children = t3;
      _._node1$_indexInParent = _._node1$_parent = null;
      _.isGroupEnd = false;
    },
    SupportsRule$0(condition, children, span) {
      var t1 = P.List_List$unmodifiable(children, type$.Statement_2),
        t2 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure0());
      return new B.SupportsRule0(condition, span, t1, t2);
    },
    SupportsRule0: function SupportsRule0(t0, t1, t2, t3) {
      var _ = this;
      _.condition = t0;
      _.span = t1;
      _.children = t2;
      _.hasDeclarations = t3;
    },
    fromImport0() {
      var t1 = H._asBoolQ($.Zone__current.$index(0, C.Symbol__inImportRule));
      return t1 === true;
    },
    resolveImportPath0(path) {
      var t1,
        extension = X.ParsedPath_ParsedPath$parse(path, $.$get$context().style)._splitExtension$1(1)[1];
      if (extension === ".sass" || extension === ".scss" || extension === ".css") {
        t1 = B.fromImport0() ? new B.resolveImportPath_closure1(path, extension).call$0() : null;
        return t1 == null ? B._exactlyOne0(B._tryPath0(path)) : t1;
      }
      t1 = B.fromImport0() ? new B.resolveImportPath_closure2(path).call$0() : null;
      if (t1 == null)
        t1 = B._exactlyOne0(B._tryPathWithExtensions0(path));
      return t1 == null ? B._tryPathAsDirectory0(path) : t1;
    },
    _tryPathWithExtensions0(path) {
      var result = B._tryPath0(path + ".sass");
      C.JSArray_methods.addAll$1(result, B._tryPath0(path + ".scss"));
      return result.length !== 0 ? result : B._tryPath0(path + ".css");
    },
    _tryPath0(path) {
      var t1 = $.$get$context(),
        partial = D.join(t1.dirname$1(path), "_" + X.ParsedPath_ParsedPath$parse(path, t1.style).get$basename(), null);
      t1 = H._setArrayType([], type$.JSArray_String);
      if (B.fileExists0(partial))
        t1.push(partial);
      if (B.fileExists0(path))
        t1.push(path);
      return t1;
    },
    _tryPathAsDirectory0(path) {
      var t1;
      if (!B.dirExists0(path))
        return null;
      t1 = B.fromImport0() ? new B._tryPathAsDirectory_closure0(path).call$0() : null;
      return t1 == null ? B._exactlyOne0(B._tryPathWithExtensions0(D.join(path, "index", null))) : t1;
    },
    _exactlyOne0(paths) {
      var t1 = paths.length;
      if (t1 === 0)
        return null;
      if (t1 === 1)
        return C.JSArray_methods.get$first(paths);
      throw H.wrapException(string$.It_s_n + C.JSArray_methods.map$1$1(paths, new B._exactlyOne_closure0(), type$.String).join$1(0, "\n"));
    },
    resolveImportPath_closure1: function resolveImportPath_closure1(t0, t1) {
      this.path = t0;
      this.extension = t1;
    },
    resolveImportPath_closure2: function resolveImportPath_closure2(t0) {
      this.path = t0;
    },
    _tryPathAsDirectory_closure0: function _tryPathAsDirectory_closure0(t0) {
      this.path = t0;
    },
    _exactlyOne_closure0: function _exactlyOne_closure0() {
    },
    jsThrow(error) {
      return type$.Never._as($.$get$_jsThrow().call$1(error));
    },
    attachJsStack(error, trace) {
      var traceString = trace.toString$0(0),
        firstRealLine = C.JSString_methods.indexOf$1(traceString, "\n    at");
      if (firstRealLine !== -1)
        traceString = C.JSString_methods.substring$1(traceString, firstRealLine + 1);
      error.stack = "Error: " + H.S(J.get$message$x(error)) + "\n" + traceString;
    },
    jsForEach(object, callback) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(self.Object.keys(object)); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        callback.call$2(t2, object[t2]);
      }
    },
    defineGetter(object, $name, get, value) {
      self.Object.defineProperty(object, $name, get == null ? {value: value, enumerable: false} : {get: P.allowInteropCaptureThis(get), enumerable: false});
    },
    allowInteropNamed($name, $function) {
      $function = P.allowInterop($function);
      B.defineGetter($function, "name", null, $name);
      B._hideDartProperties($function);
      return $function;
    },
    allowInteropCaptureThisNamed($name, $function) {
      $function = P.allowInteropCaptureThis($function);
      B.defineGetter($function, "name", null, $name);
      B._hideDartProperties($function);
      return $function;
    },
    _hideDartProperties(object) {
      var t1, t2, t3, t4;
      for (t1 = J.cast$1$0$ax(self.Object.getOwnPropertyNames(object), type$.String), t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = H._instanceType(t1)._precomputed1; t1.moveNext$0();) {
        t3 = t2._as(t1.__internal$_current);
        if (C.JSString_methods.startsWith$1(t3, "_")) {
          t4 = {value: object[t3], enumerable: false};
          self.Object.defineProperty(object, t3, t4);
        }
      }
    },
    dartToJSUrl(url) {
      return new self.URL(url.toString$0(0));
    },
    _PropertyDescriptor0: function _PropertyDescriptor0() {
    },
    toSentence0(iter, conjunction) {
      var t1 = iter.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1);
      if (t2.get$length(t1) === 1)
        return J.toString$0$(iter._f.call$1(t2.get$first(t1)));
      return H.TakeIterable_TakeIterable(iter, t2.get$length(t1) - 1, H._instanceType(iter)._eval$1("Iterable.E")).join$1(0, ", ") + (" " + conjunction + " " + H.S(iter._f.call$1(t2.get$last(t1))));
    },
    indent0(string, indentation) {
      return new H.MappedListIterable(H._setArrayType(string.split("\n"), type$.JSArray_String), new B.indent_closure0(indentation), type$.MappedListIterable_String_String).join$1(0, "\n");
    },
    pluralize0($name, number, plural) {
      if (number === 1)
        return $name;
      if (plural != null)
        return plural;
      return $name + "s";
    },
    trimAscii0(string, excludeEscape) {
      var t1,
        start = B._firstNonWhitespace0(string);
      if (start == null)
        t1 = "";
      else {
        t1 = B._lastNonWhitespace0(string, true);
        t1.toString;
        t1 = C.JSString_methods.substring$2(string, start, t1 + 1);
      }
      return t1;
    },
    trimAsciiRight0(string, excludeEscape) {
      var end = B._lastNonWhitespace0(string, excludeEscape);
      return end == null ? "" : C.JSString_methods.substring$2(string, 0, end + 1);
    },
    _firstNonWhitespace0(string) {
      var t1, i, t2;
      for (t1 = string.length, i = 0; i < t1; ++i) {
        t2 = C.JSString_methods._codeUnitAt$1(string, i);
        if (!(t2 === 32 || t2 === 9 || t2 === 10 || t2 === 13 || t2 === 12))
          return i;
      }
      return null;
    },
    _lastNonWhitespace0(string, excludeEscape) {
      var t1, i, codeUnit;
      for (t1 = string.length, i = t1 - 1; i >= 0; --i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(string, i);
        if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
          if (excludeEscape && i !== 0 && i !== t1 && codeUnit === 92)
            return i + 1;
          else
            return i;
      }
      return null;
    },
    isPublic0(member) {
      var start = C.JSString_methods._codeUnitAt$1(member, 0);
      return start !== 45 && start !== 95;
    },
    flattenVertically0(iterable, $T) {
      var result,
        t1 = iterable.$ti._eval$1("@<ListIterable.E>")._bind$1($T._eval$1("QueueList<0>"))._eval$1("MappedListIterable<1,2>"),
        queues = P.List_List$of(new H.MappedListIterable(iterable, new B.flattenVertically_closure1($T), t1), true, t1._eval$1("ListIterable.E"));
      if (queues.length === 1)
        return C.JSArray_methods.get$first(queues);
      result = H._setArrayType([], $T._eval$1("JSArray<0>"));
      for (; queues.length !== 0;) {
        if (!!queues.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeWhere"));
        C.JSArray_methods._removeWhere$2(queues, new B.flattenVertically_closure2(result, $T), true);
      }
      return result;
    },
    firstOrNull0(iterable) {
      var iterator = J.get$iterator$ax(iterable);
      return iterator.moveNext$0() ? iterator.get$current(iterator) : null;
    },
    codepointIndexToCodeUnitIndex0(string, codepointIndex) {
      var codeUnitIndex, i, codeUnitIndex0;
      for (codeUnitIndex = 0, i = 0; i < codepointIndex; ++i) {
        codeUnitIndex0 = codeUnitIndex + 1;
        codeUnitIndex = C.JSString_methods._codeUnitAt$1(string, codeUnitIndex) >>> 10 === 54 ? codeUnitIndex0 + 1 : codeUnitIndex0;
      }
      return codeUnitIndex;
    },
    codeUnitIndexToCodepointIndex0(string, codeUnitIndex) {
      var codepointIndex, i;
      for (codepointIndex = 0, i = 0; i < codeUnitIndex; i = (C.JSString_methods._codeUnitAt$1(string, i) >>> 10 === 54 ? i + 1 : i) + 1)
        ++codepointIndex;
      return codepointIndex;
    },
    frameForSpan0(span, member, url) {
      var t2, t3, t4,
        t1 = url == null ? span.file.url : url;
      if (t1 == null)
        t1 = $.$get$_noSourceUrl0();
      t2 = span.file;
      t3 = span._file$_start;
      t4 = Y.FileLocation$_(t2, t3);
      t4 = t4.file.getLine$1(t4.offset);
      t3 = Y.FileLocation$_(t2, t3);
      return new A.Frame(t1, t4 + 1, t3.file.getColumn$1(t3.offset) + 1, member);
    },
    declarationName0(span) {
      var text = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(span.file._decodedChars, span._file$_start, span._end), 0, null);
      return B.trimAsciiRight0(C.JSString_methods.substring$2(text, 0, C.JSString_methods.indexOf$1(text, ":")), false);
    },
    unvendor0($name) {
      var i,
        t1 = $name.length;
      if (t1 < 2)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 0) !== 45)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 1) === 45)
        return $name;
      for (i = 2; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1($name, i) === 45)
          return C.JSString_methods.substring$1($name, i + 1);
      return $name;
    },
    equalsIgnoreCase0(string1, string2) {
      var t1, i;
      if (string1 === string2)
        return true;
      if (string1 == null || false)
        return false;
      t1 = string1.length;
      if (t1 !== string2.length)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase0(C.JSString_methods._codeUnitAt$1(string1, i), C.JSString_methods._codeUnitAt$1(string2, i)))
          return false;
      return true;
    },
    startsWithIgnoreCase0(string, prefix) {
      var i,
        t1 = prefix.length;
      if (string.length < t1)
        return false;
      for (i = 0; i < t1; ++i)
        if (!T.characterEqualsIgnoreCase0(C.JSString_methods._codeUnitAt$1(string, i), C.JSString_methods._codeUnitAt$1(prefix, i)))
          return false;
      return true;
    },
    mapInPlace0(list, $function) {
      var i;
      for (i = 0; i < list.length; ++i)
        list[i] = $function.call$1(list[i]);
    },
    longestCommonSubsequence0(list1, list2, select, $T) {
      var t1, _length, lengths, t2, t3, _i, selections, i, i0, j, selection, j0;
      if (select == null)
        select = new B.longestCommonSubsequence_closure0($T);
      t1 = J.getInterceptor$asx(list1);
      _length = t1.get$length(list1) + 1;
      lengths = J.JSArray_JSArray$allocateFixed(_length, type$.List_int);
      for (t2 = J.getInterceptor$asx(list2), t3 = type$.int, _i = 0; _i < _length; ++_i)
        lengths[_i] = P.List_List$filled(t2.get$length(list2) + 1, 0, false, t3);
      _length = t1.get$length(list1);
      selections = J.JSArray_JSArray$allocateFixed(_length, $T._eval$1("List<0?>"));
      for (t3 = $T._eval$1("0?"), _i = 0; _i < _length; ++_i)
        selections[_i] = P.List_List$filled(t2.get$length(list2), null, false, t3);
      for (i = 0; i < t1.get$length(list1); i = i0)
        for (i0 = i + 1, j = 0; j < t2.get$length(list2); j = j0) {
          selection = select.call$2(t1.$index(list1, i), t2.$index(list2, j));
          selections[i][j] = selection;
          t3 = lengths[i0];
          j0 = j + 1;
          t3[j0] = selection == null ? Math.max(t3[j], lengths[i][j0]) : lengths[i][j] + 1;
        }
      return new B.longestCommonSubsequence_backtrack0(selections, lengths, $T).call$2(t1.get$length(list1) - 1, t2.get$length(list2) - 1);
    },
    removeFirstWhere0(list, test, orElse) {
      var i;
      for (i = 0; i < list.length; ++i) {
        if (!test.call$1(list[i]))
          continue;
        C.JSArray_methods.removeAt$1(list, i);
        return;
      }
      orElse.call$0();
    },
    mapAddAll20(destination, source, K1, K2, $V) {
      source.forEach$1(0, new B.mapAddAll2_closure0(destination, K1, K2, $V));
    },
    setAll0(map, keys, value) {
      var t1;
      for (t1 = J.get$iterator$ax(keys); t1.moveNext$0();)
        map.$indexSet(0, t1.get$current(t1), value);
    },
    rotateSlice0(list, start, end) {
      var i, next,
        element = list.$index(0, end - 1);
      for (i = start; i < end; ++i, element = next) {
        next = list.$index(0, i);
        list.$indexSet(0, i, element);
      }
    },
    mapAsync0(iterable, callback, $E, $F) {
      return B.mapAsync$body0(iterable, callback, $E, $F, $F._eval$1("Iterable<0>"));
    },
    mapAsync$body0(iterable, callback, $E, $F, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, t2, _i, t1, $async$temp1;
      var $async$mapAsync0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H._setArrayType([], $F._eval$1("JSArray<0>"));
              t2 = iterable.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = t1;
              $async$goto = 6;
              return P._asyncAwait(callback.call$1(iterable[_i]), $async$mapAsync0);
            case 6:
              // returning from await.
              $async$temp1.push($async$result);
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapAsync0, $async$completer);
    },
    putIfAbsentAsync0(map, key, ifAbsent, $K, $V) {
      return B.putIfAbsentAsync$body0(map, key, ifAbsent, $K, $V, $V);
    },
    putIfAbsentAsync$body0(map, key, ifAbsent, $K, $V, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, value;
      var $async$putIfAbsentAsync0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (map.containsKey$1(key)) {
                $async$returnValue = $V._as(map.$index(0, key));
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(ifAbsent.call$0(), $async$putIfAbsentAsync0);
            case 3:
              // returning from await.
              value = $async$result;
              map.$indexSet(0, key, value);
              $async$returnValue = value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$putIfAbsentAsync0, $async$completer);
    },
    copyMapOfMap0(map, K1, K2, $V) {
      var t2, t3, t4, t5,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(K1, K2._eval$1("@<0>")._bind$1($V)._eval$1("Map<1,2>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t4 = t3.key;
        t3 = t3.value;
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, K2, $V);
        t5.addAll$1(0, t3);
        t1.$indexSet(0, t4, t5);
      }
      return t1;
    },
    copyMapOfList0(map, $K, $E) {
      var t2, t3,
        t1 = P.LinkedHashMap_LinkedHashMap$_empty($K, $E._eval$1("List<0>"));
      for (t2 = map.get$entries(map), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        t1.$indexSet(0, t3.key, J.toList$0$ax(t3.value));
      }
      return t1;
    },
    consumeEscapedCharacter0(scanner) {
      var first, value, i, next, t1;
      scanner.expectChar$1(92);
      first = scanner.peekChar$0();
      if (first == null)
        return 65533;
      else if (first === 10 || first === 13 || first === 12)
        scanner.error$1(0, "Expected escape sequence.");
      else if (T.isHex0(first)) {
        for (value = 0, i = 0; i < 6; ++i) {
          next = scanner.peekChar$0();
          if (next == null || !T.isHex0(next))
            break;
          value = (value << 4 >>> 0) + T.asHex0(scanner.readChar$0());
        }
        t1 = scanner.peekChar$0();
        if (t1 === 32 || t1 === 9 || t1 === 10 || t1 === 13 || t1 === 12)
          scanner.readChar$0();
        if (value !== 0)
          t1 = value >= 55296 && value <= 57343 || value >= 1114111;
        else
          t1 = true;
        if (t1)
          return 65533;
        else
          return value;
      } else
        return scanner.readChar$0();
    },
    throwWithTrace0(error, trace) {
      B.attachTrace0(error, trace);
      throw H.wrapException(error);
    },
    attachTrace0(error, trace) {
      var t1;
      if (typeof error == "string" || typeof error == "number" || H._isBool(error))
        return;
      if (trace.toString$0(0).length === 0)
        return;
      t1 = $.$get$_traces0();
      P.Expando__checkType(error);
      t1 = t1._jsWeakMap;
      if (t1.get(error) == null)
        t1.set(error, trace);
    },
    getTrace0(error) {
      var t1;
      if (typeof error == "string" || typeof error == "number" || H._isBool(error))
        t1 = null;
      else {
        t1 = $.$get$_traces0();
        P.Expando__checkType(error);
        t1 = t1._jsWeakMap.get(error);
      }
      return t1;
    },
    indent_closure0: function indent_closure0(t0) {
      this.indentation = t0;
    },
    flattenVertically_closure1: function flattenVertically_closure1(t0) {
      this.T = t0;
    },
    flattenVertically_closure2: function flattenVertically_closure2(t0, t1) {
      this.result = t0;
      this.T = t1;
    },
    longestCommonSubsequence_closure0: function longestCommonSubsequence_closure0(t0) {
      this.T = t0;
    },
    longestCommonSubsequence_backtrack0: function longestCommonSubsequence_backtrack0(t0, t1, t2) {
      this.selections = t0;
      this.lengths = t1;
      this.T = t2;
    },
    mapAddAll2_closure0: function mapAddAll2_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.destination = t0;
      _.K1 = t1;
      _.K2 = t2;
      _.V = t3;
    },
    defaultCompare(value1, value2) {
      return J.compareTo$1$ns(type$.Comparable_nullable_Object._as(value1), value2);
    },
    isAlphabetic(char) {
      var t1;
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    },
    isDriveLetter(path, index) {
      var t1 = path.length,
        t2 = index + 2;
      if (t1 < t2)
        return false;
      if (!B.isAlphabetic(C.JSString_methods.codeUnitAt$1(path, index)))
        return false;
      if (C.JSString_methods.codeUnitAt$1(path, index + 1) !== 58)
        return false;
      if (t1 === t2)
        return true;
      return C.JSString_methods.codeUnitAt$1(path, t2) === 47;
    },
    isAllTheSame(iter) {
      var firstValue, t1, t2;
      if (iter.get$length(iter) === 0)
        return true;
      firstValue = iter.get$first(iter);
      for (t1 = H.SubListIterable$(iter, 1, null, iter.$ti._eval$1("ListIterable.E")), t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = H._instanceType(t1)._precomputed1; t1.moveNext$0();)
        if (!J.$eq$(t2._as(t1.__internal$_current), firstValue))
          return false;
      return true;
    },
    replaceFirstNull(list, element) {
      var index = C.JSArray_methods.indexOf$1(list, null);
      if (index < 0)
        throw H.wrapException(P.ArgumentError$(H.S(list) + " contains no null elements.", null));
      list[index] = element;
    },
    replaceWithNull(list, element) {
      var index = C.JSArray_methods.indexOf$1(list, element);
      if (index < 0)
        throw H.wrapException(P.ArgumentError$(H.S(list) + " contains no elements matching " + element.toString$0(0) + ".", null));
      list[index] = null;
    },
    countCodeUnits(string, codeUnit) {
      var t1, t2, count;
      for (t1 = new H.CodeUnits(string), t1 = new H.ListIterator(t1, t1.get$length(t1)), t2 = H._instanceType(t1)._precomputed1, count = 0; t1.moveNext$0();)
        if (t2._as(t1.__internal$_current) === codeUnit)
          ++count;
      return count;
    },
    findLineStart(context, text, column) {
      var beginningOfLine, index, lineStart;
      if (text.length === 0)
        for (beginningOfLine = 0; true;) {
          index = C.JSString_methods.indexOf$2(context, "\n", beginningOfLine);
          if (index === -1)
            return context.length - beginningOfLine >= column ? beginningOfLine : null;
          if (index - beginningOfLine >= column)
            return beginningOfLine;
          beginningOfLine = index + 1;
        }
      index = C.JSString_methods.indexOf$1(context, text);
      for (; index !== -1;) {
        lineStart = index === 0 ? 0 : C.JSString_methods.lastIndexOf$2(context, "\n", index - 1) + 1;
        if (column === index - lineStart)
          return lineStart;
        index = C.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return null;
    },
    validateErrorArgs(string, match, position, $length) {
      var t2,
        t1 = position != null;
      if (t1)
        if (position < 0)
          throw H.wrapException(P.RangeError$("position must be greater than or equal to 0."));
        else if (position > string.length)
          throw H.wrapException(P.RangeError$("position must be less than or equal to the string length."));
      t2 = $length != null;
      if (t2 && $length < 0)
        throw H.wrapException(P.RangeError$("length must be greater than or equal to 0."));
      if (t1 && t2 && position + $length > string.length)
        throw H.wrapException(P.RangeError$("position plus length must not go beyond the end of the string."));
    },
    main() {
      J.set$info$x(self.exports, "dart-sass\t1.44.0\t(Sass Compiler)\t[Dart]\ndart2js\t2.14.4\t(Dart Compiler)\t[Dart]");
      V.updateSourceSpanPrototype();
      J.set$render$x(self.exports, B.allowInteropNamed("sass.render", Q.legacy__render$closure()));
      J.set$renderSync$x(self.exports, B.allowInteropNamed("sass.renderSync", Q.legacy__renderSync$closure()));
      J.set$types$x(self.exports, {Boolean: $.$get$legacyBooleanClass(), Color: $.$get$legacyColorClass(), List: $.$get$legacyListClass(), Map: $.$get$legacyMapClass(), Null: $.$get$legacyNullClass(), Number: $.$get$legacyNumberClass(), String: $.$get$legacyStringClass(), Error: self.Error});
      J.set$NULL$x(self.exports, C.C__SassNull0);
      J.set$TRUE$x(self.exports, C.SassBoolean_true0);
      J.set$FALSE$x(self.exports, C.SassBoolean_false0);
    }
  },
  C = {},
  D = {
    fs() {
      var t1 = $._fs;
      return t1 == null ? $._fs = self.fs : t1;
    },
    FS: function FS() {
    },
    FSConstants: function FSConstants() {
    },
    FSWatcher: function FSWatcher() {
    },
    ReadStream: function ReadStream() {
    },
    ReadStreamOptions: function ReadStreamOptions() {
    },
    WriteStream: function WriteStream() {
    },
    WriteStreamOptions: function WriteStreamOptions() {
    },
    FileOptions: function FileOptions() {
    },
    StatOptions: function StatOptions() {
    },
    MkdirOptions: function MkdirOptions() {
    },
    RmdirOptions: function RmdirOptions() {
    },
    WatchOptions: function WatchOptions() {
    },
    WatchFileOptions: function WatchFileOptions() {
    },
    Stats: function Stats() {
    },
    StreamModule: function StreamModule() {
    },
    Readable: function Readable() {
    },
    Writable: function Writable() {
    },
    Duplex: function Duplex() {
    },
    Transform: function Transform() {
    },
    WritableOptions: function WritableOptions() {
    },
    ReadableOptions: function ReadableOptions() {
    },
    ListExpression: function ListExpression(t0, t1, t2, t3) {
      var _ = this;
      _.contents = t0;
      _.separator = t1;
      _.hasBrackets = t2;
      _.span = t3;
    },
    ListExpression_toString_closure: function ListExpression_toString_closure(t0) {
      this.$this = t0;
    },
    StringExpression_quoteText(text) {
      var t1,
        quote = D.StringExpression__bestQuote(H._setArrayType([text], type$.JSArray_String)),
        buffer = new P.StringBuffer("");
      buffer._contents = "" + H.Primitives_stringFromCharCode(quote);
      D.StringExpression__quoteInnerText(text, quote, buffer, true);
      t1 = buffer._contents += H.Primitives_stringFromCharCode(quote);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    StringExpression__quoteInnerText(text, quote, buffer, $static) {
      var t1, t2, i, codeUnit, next, t3;
      for (t1 = text.length, t2 = t1 - 1, i = 0; i < t1; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(text, i);
        if (codeUnit === 10 || codeUnit === 13 || codeUnit === 12) {
          buffer.writeCharCode$1(92);
          buffer.writeCharCode$1(97);
          if (i !== t2) {
            next = C.JSString_methods._codeUnitAt$1(text, i + 1);
            if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12 || T.isHex(next))
              buffer.writeCharCode$1(32);
          }
        } else {
          if (codeUnit !== quote)
            if (codeUnit !== 92)
              t3 = $static && codeUnit === 35 && i < t2 && C.JSString_methods._codeUnitAt$1(text, i + 1) === 123;
            else
              t3 = true;
          else
            t3 = true;
          if (t3)
            buffer.writeCharCode$1(92);
          buffer.writeCharCode$1(codeUnit);
        }
      }
    },
    StringExpression__bestQuote(strings) {
      var t1, containsDoubleQuote, t2, t3, i, codeUnit;
      for (t1 = J.get$iterator$ax(strings), containsDoubleQuote = false; t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        for (t3 = t2.length, i = 0; i < t3; ++i) {
          codeUnit = C.JSString_methods._codeUnitAt$1(t2, i);
          if (codeUnit === 39)
            return 34;
          if (codeUnit === 34)
            containsDoubleQuote = true;
        }
      }
      return containsDoubleQuote ? 39 : 34;
    },
    StringExpression: function StringExpression(t0, t1) {
      this.text = t0;
      this.hasQuotes = t1;
    },
    ErrorRule: function ErrorRule(t0, t1) {
      this.expression = t0;
      this.span = t1;
    },
    SelectorList$(components) {
      var t1 = P.List_List$unmodifiable(components, type$.ComplexSelector);
      if (t1.length === 0)
        H.throwExpression(P.ArgumentError$("components may not be empty.", null));
      return new D.SelectorList(t1);
    },
    SelectorList_SelectorList$parse(contents, allowParent, allowPlaceholder, logger) {
      return T.SelectorParser$(contents, allowParent, allowPlaceholder, logger, null).parse$0();
    },
    SelectorList: function SelectorList(t0) {
      this.components = t0;
    },
    SelectorList_isInvisible_closure: function SelectorList_isInvisible_closure() {
    },
    SelectorList_asSassList_closure: function SelectorList_asSassList_closure() {
    },
    SelectorList_asSassList__closure: function SelectorList_asSassList__closure() {
    },
    SelectorList_unify_closure: function SelectorList_unify_closure(t0) {
      this.other = t0;
    },
    SelectorList_unify__closure: function SelectorList_unify__closure(t0) {
      this.complex1 = t0;
    },
    SelectorList_unify___closure: function SelectorList_unify___closure() {
    },
    SelectorList_resolveParentSelectors_closure: function SelectorList_resolveParentSelectors_closure(t0, t1, t2) {
      this.$this = t0;
      this.implicitParent = t1;
      this.parent = t2;
    },
    SelectorList_resolveParentSelectors__closure: function SelectorList_resolveParentSelectors__closure(t0) {
      this.complex = t0;
    },
    SelectorList_resolveParentSelectors__closure0: function SelectorList_resolveParentSelectors__closure0(t0) {
      this._box_0 = t0;
    },
    SelectorList__complexContainsParentSelector_closure: function SelectorList__complexContainsParentSelector_closure() {
    },
    SelectorList__complexContainsParentSelector__closure: function SelectorList__complexContainsParentSelector__closure() {
    },
    SelectorList__resolveParentSelectorsCompound_closure: function SelectorList__resolveParentSelectorsCompound_closure() {
    },
    SelectorList__resolveParentSelectorsCompound_closure0: function SelectorList__resolveParentSelectorsCompound_closure0(t0) {
      this.parent = t0;
    },
    SelectorList__resolveParentSelectorsCompound_closure1: function SelectorList__resolveParentSelectorsCompound_closure1(t0, t1) {
      this.compound = t0;
      this.resolvedMembers = t1;
    },
    PseudoSelector$($name, argument, element, selector) {
      var t1 = !element,
        t2 = t1 && !D.PseudoSelector__isFakePseudoElement($name);
      return new D.PseudoSelector($name, B.unvendor($name), t2, t1, argument, selector);
    },
    PseudoSelector__isFakePseudoElement($name) {
      switch (C.JSString_methods._codeUnitAt$1($name, 0)) {
        case 97:
        case 65:
          return B.equalsIgnoreCase($name, "after");
        case 98:
        case 66:
          return B.equalsIgnoreCase($name, "before");
        case 102:
        case 70:
          return B.equalsIgnoreCase($name, "first-line") || B.equalsIgnoreCase($name, "first-letter");
        default:
          return false;
      }
    },
    PseudoSelector: function PseudoSelector(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.name = t0;
      _.normalizedName = t1;
      _.isClass = t2;
      _.isSyntacticClass = t3;
      _.argument = t4;
      _.selector = t5;
      _._pseudo$_maxSpecificity = _._pseudo$_minSpecificity = null;
    },
    PseudoSelector_unify_closure: function PseudoSelector_unify_closure() {
    },
    QualifiedName: function QualifiedName(t0, t1) {
      this.name = t0;
      this.namespace = t1;
    },
    compileStylesheet(options, graph, source, destination, ifModified) {
      return D.compileStylesheet$body(options, graph, source, destination, ifModified);
    },
    compileStylesheet$body(options, graph, source, destination, ifModified) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], syntax, result, importCache, error, exception, t2, t3, t4, t5, t6, t7, t8, t9, t10, result0, logger, terseLogger, stylesheet, css, buffer, sourceName, destinationName, t1, importer, $async$exception;
      var $async$compileStylesheet = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$context();
              importer = new F.FilesystemImporter(t1.absolute$7(".", null, null, null, null, null, null));
              if (ifModified)
                try {
                  if (source != null && destination != null && !graph.modifiedSince$3(t1.toUri$1(source), B.modificationTime(destination), importer)) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                } catch (exception) {
                  if (!(H.unwrapException(exception) instanceof B.FileSystemException))
                    throw exception;
                }
              syntax = null;
              if (H._asBoolQ(options._ifParsed$1("indented")) === true)
                syntax = C.Syntax_Sass;
              else if (source != null)
                syntax = M.Syntax_forPath(source);
              else
                syntax = C.Syntax_SCSS;
              result = null;
              $async$handler = 4;
              t2 = options._options;
              $async$goto = H._asBool(t2.$index(0, "async")) ? 7 : 9;
              break;
            case 7:
              // then
              t3 = type$.List_String._as(t2.$index(0, "load-path"));
              t4 = H._asBool(t2.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t5 = type$.nullable_Tuple3_AsyncImporter_Uri_Uri;
              t6 = type$.Uri;
              t3 = O.AsyncImportCache__toImporters(null, t3, null);
              importCache = new O.AsyncImportCache(t3, t4, P.LinkedHashMap_LinkedHashMap$_empty(type$.Tuple2_Uri_bool, t5), P.LinkedHashMap_LinkedHashMap$_empty(type$.Tuple4_of_Uri_and_bool_and_AsyncImporter_and_nullable_Uri, t5), P.LinkedHashMap_LinkedHashMap$_empty(t6, type$.nullable_Stylesheet), P.LinkedHashMap_LinkedHashMap$_empty(t6, type$.ImporterResult));
              $async$goto = source == null ? 10 : 12;
              break;
            case 10:
              // then
              $async$goto = 13;
              return P._asyncAwait(B.readStdin(), $async$compileStylesheet);
            case 13:
              // returning from await.
              t3 = $async$result;
              t4 = syntax;
              t5 = H._asBool(t2.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t6 = t1.absolute$7(".", null, null, null, null, null, null);
              t7 = J.$eq$(t2.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t8 = H._asBool(t2.$index(0, "quiet-deps"));
              t9 = H._asBool(t2.$index(0, "verbose"));
              t10 = options.get$emitSourceMap();
              $async$goto = 14;
              return P._asyncAwait(X.compileStringAsync(t3, H._asBool(t2.$index(0, "charset")), importCache, new F.FilesystemImporter(t6), t5, t8, t10, t7, t4, t9), $async$compileStylesheet);
            case 14:
              // returning from await.
              result0 = $async$result;
              // goto join
              $async$goto = 11;
              break;
            case 12:
              // else
              t3 = syntax;
              t4 = H._asBool(t2.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t5 = J.$eq$(t2.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t6 = H._asBool(t2.$index(0, "quiet-deps"));
              t7 = H._asBool(t2.$index(0, "verbose"));
              t8 = options.get$emitSourceMap();
              $async$goto = 15;
              return P._asyncAwait(X.compileAsync(source, H._asBool(t2.$index(0, "charset")), importCache, t4, t6, t8, t5, t3, t7), $async$compileStylesheet);
            case 15:
              // returning from await.
              result0 = $async$result;
            case 11:
              // join
              result = result0;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = source == null ? 16 : 18;
              break;
            case 16:
              // then
              $async$goto = 19;
              return P._asyncAwait(B.readStdin(), $async$compileStylesheet);
            case 19:
              // returning from await.
              t3 = $async$result;
              t4 = syntax;
              logger = H._asBool(t2.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t5 = t1.absolute$7(".", null, null, null, null, null, null);
              t6 = J.$eq$(t2.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t7 = H._asBool(t2.$index(0, "quiet-deps"));
              t8 = H._asBool(t2.$index(0, "verbose"));
              t9 = options.get$emitSourceMap();
              t2 = H._asBool(t2.$index(0, "charset"));
              if (!t8) {
                terseLogger = new Y.TerseLogger(P.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.int), logger);
                logger = terseLogger;
              } else
                terseLogger = null;
              stylesheet = V.Stylesheet_Stylesheet$parse(t3, t4 == null ? C.Syntax_SCSS : t4, logger, null);
              result0 = U._compileStylesheet(stylesheet, logger, graph.importCache, null, new F.FilesystemImporter(t5), null, t6, true, null, null, t7, t9, t2);
              if (terseLogger != null)
                terseLogger.summarize$1$node(false);
              // goto join
              $async$goto = 17;
              break;
            case 18:
              // else
              t3 = syntax;
              logger = H._asBool(t2.$index(0, "quiet")) ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              importCache = graph.importCache;
              t4 = J.$eq$(t2.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              t5 = H._asBool(t2.$index(0, "quiet-deps"));
              t6 = H._asBool(t2.$index(0, "verbose"));
              t7 = options.get$emitSourceMap();
              t2 = H._asBool(t2.$index(0, "charset"));
              if (!t6) {
                terseLogger = new Y.TerseLogger(P.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.int), logger);
                logger = terseLogger;
              } else
                terseLogger = null;
              t6 = t3 == null || t3 === M.Syntax_forPath(source);
              if (t6) {
                t3 = t1.absolute$7(".", null, null, null, null, null, null);
                t3 = importCache.importCanonical$3$originalUrl(new F.FilesystemImporter(t3), t1.toUri$1(J.$eq$(J.get$platform$x(self.process), "win32") || J.$eq$(J.get$platform$x(self.process), "darwin") ? F._realCasePath(t1.absolute$7(t1.normalize$1(source), null, null, null, null, null, null)) : t1.canonicalize$1(0, source)), t1.toUri$1(source));
                t3.toString;
                stylesheet = t3;
              } else {
                t6 = B.readFile(source);
                if (t3 == null)
                  t3 = M.Syntax_forPath(source);
                stylesheet = V.Stylesheet_Stylesheet$parse(t6, t3, logger, t1.toUri$1(source));
              }
              result0 = U._compileStylesheet(stylesheet, logger, importCache, null, new F.FilesystemImporter(t1.absolute$7(".", null, null, null, null, null, null)), null, t4, true, null, null, t5, t7, t2);
              if (terseLogger != null)
                terseLogger.summarize$1$node(false);
            case 17:
              // join
              result = result0;
            case 8:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t2 = H.unwrapException($async$exception);
              if (t2 instanceof E.SassException) {
                error = t2;
                if (options.get$emitErrorCss())
                  if (destination == null)
                    P.print(error.toCssString$0());
                  else {
                    B.ensureDir(t1.dirname$1(destination));
                    B.writeFile(destination, error.toCssString$0() + "\n");
                  }
                throw $async$exception;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              css = result._serialize.css + D._writeSourceMap(options, result._serialize.sourceMap, destination);
              if (destination == null) {
                if (css.length !== 0)
                  P.print(css);
              } else {
                B.ensureDir(t1.dirname$1(destination));
                B.writeFile(destination, css + "\n");
              }
              t2 = options._options;
              if (!H._asBool(t2.$index(0, "quiet")))
                t2 = !H._asBool(t2.$index(0, "update")) && !H._asBool(t2.$index(0, "watch"));
              else
                t2 = true;
              if (t2) {
                // goto return
                $async$goto = 1;
                break;
              }
              buffer = new P.StringBuffer("");
              t2 = options.get$color() ? buffer._contents = "" + "\x1b[32m" : "";
              sourceName = source == null ? "stdin" : t1.prettyUri$1(t1.toUri$1(source));
              destination.toString;
              destinationName = t1.prettyUri$1(t1.toUri$1(destination));
              t1 = t2 + ("Compiled " + sourceName + " to " + destinationName + ".");
              buffer._contents = t1;
              if (options.get$color())
                buffer._contents = t1 + "\x1b[0m";
              P.print(buffer);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileStylesheet, $async$completer);
    },
    _writeSourceMap(options, sourceMap, destination) {
      var t1, sourceMapText, url, sourceMapPath, t2;
      if (sourceMap == null)
        return "";
      if (destination != null) {
        t1 = $.$get$context();
        sourceMap.targetUrl = t1.toUri$1(X.ParsedPath_ParsedPath$parse(destination, t1.style).get$basename()).toString$0(0);
      }
      B.mapInPlace(sourceMap.urls, new D._writeSourceMap_closure(options, destination));
      t1 = options._options;
      sourceMapText = C.C_JsonCodec.encode$2$toEncodable(sourceMap.toJson$1$includeSourceContents(H._asBool(t1.$index(0, "embed-sources"))), null);
      if (H._asBool(t1.$index(0, "embed-source-map")))
        url = P.Uri_Uri$dataFromString(sourceMapText, C.C_Utf8Codec, "application/json");
      else {
        destination.toString;
        sourceMapPath = destination + ".map";
        t2 = $.$get$context();
        B.ensureDir(t2.dirname$1(sourceMapPath));
        B.writeFile(sourceMapPath, sourceMapText);
        url = t2.toUri$1(t2.relative$2$from(sourceMapPath, t2.dirname$1(destination)));
      }
      t1 = (J.$eq$(t1.$index(0, "style"), "compressed") ? C.OutputStyle_compressed : C.OutputStyle_expanded) === C.OutputStyle_compressed ? "" 