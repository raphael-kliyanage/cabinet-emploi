{"version":3,"file":"router.mjs","sources":["../../../../../../packages/router/src/events.ts","../../../../../../packages/router/src/shared.ts","../../../../../../packages/router/src/utils/collection.ts","../../../../../../packages/router/src/url_tree.ts","../../../../../../packages/router/src/utils/tree.ts","../../../../../../packages/router/src/router_state.ts","../../../../../../packages/router/src/create_router_state.ts","../../../../../../packages/router/src/create_url_tree.ts","../../../../../../packages/router/src/operators/activate_routes.ts","../../../../../../packages/router/src/config.ts","../../../../../../packages/router/src/utils/type_guards.ts","../../../../../../packages/router/src/operators/prioritized_guard_value.ts","../../../../../../packages/router/src/router_outlet_context.ts","../../../../../../packages/router/src/directives/router_outlet.ts","../../../../../../packages/router/src/components/empty_outlet.ts","../../../../../../packages/router/src/utils/config.ts","../../../../../../packages/router/src/utils/config_matching.ts","../../../../../../packages/router/src/apply_redirects.ts","../../../../../../packages/router/src/operators/apply_redirects.ts","../../../../../../packages/router/src/utils/preactivation.ts","../../../../../../packages/router/src/operators/check_guards.ts","../../../../../../packages/router/src/recognize.ts","../../../../../../packages/router/src/operators/recognize.ts","../../../../../../packages/router/src/operators/resolve_data.ts","../../../../../../packages/router/src/operators/switch_tap.ts","../../../../../../packages/router/src/route_reuse_strategy.ts","../../../../../../packages/router/src/router_config_loader.ts","../../../../../../packages/router/src/url_handling_strategy.ts","../../../../../../packages/router/src/router.ts","../../../../../../packages/router/src/directives/router_link.ts","../../../../../../packages/router/src/directives/router_link_active.ts","../../../../../../packages/router/src/router_preloader.ts","../../../../../../packages/router/src/router_scroller.ts","../../../../../../packages/router/src/router_module.ts","../../../../../../packages/router/src/version.ts","../../../../../../packages/router/src/private_export.ts","../../../../../../packages/router/src/index.ts","../../../../../../packages/router/public_api.ts","../../../../../../packages/router/index.ts","../../../../../../packages/router/router.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route} from './config';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n\n/**\n * Identifies the call or event that triggered a navigation.\n *\n * * 'imperative': Triggered by `router.navigateByUrl()` or `router.navigate()`.\n * * 'popstate' : Triggered by a `popstate` event.\n * * 'hashchange'-: Triggered by a `hashchange` event.\n *\n * @publicApi\n */\nexport type NavigationTrigger = 'imperative'|'popstate'|'hashchange';\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @see [Router events summary](guide/router-reference#router-events)\n * @publicApi\n */\nexport class RouterEvent {\n  constructor(\n      /** A unique ID that the router assigns to every router navigation. */\n      public id: number,\n      /** The URL that is the destination for this navigation. */\n      public url: string) {}\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport class NavigationStart extends RouterEvent {\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see `NavigationEnd`\n   * @see `NavigationCancel`\n   * @see `NavigationError`\n   */\n  navigationTrigger?: 'imperative'|'popstate'|'hashchange';\n\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState?: {[k: string]: any, navigationId: number}|null;\n\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      navigationTrigger: 'imperative'|'popstate'|'hashchange' = 'imperative',\n      /** @docsNotRequired */\n      restoredState: {[k: string]: any, navigationId: number}|null = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see `NavigationStart`\n * @see `NavigationCancel`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport class NavigationEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationError`\n *\n * @publicApi\n */\nexport class NavigationCancel extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public reason: string) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see `NavigationStart`\n * @see `NavigationEnd`\n * @see `NavigationCancel`\n *\n * @publicApi\n */\nexport class NavigationError extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public error: any) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\n\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport class RoutesRecognized extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  /** @docsNotRequired */\n  override toString(): string {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see `GuardsCheckEnd`\n *\n * @publicApi\n */\nexport class GuardsCheckStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see `GuardsCheckStart`\n *\n * @publicApi\n */\nexport class GuardsCheckEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot,\n      /** @docsNotRequired */\n      public shouldActivate: boolean) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\n\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see `ResolveEnd`\n *\n * @publicApi\n */\nexport class ResolveStart extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport class ResolveEnd extends RouterEvent {\n  constructor(\n      /** @docsNotRequired */\n      id: number,\n      /** @docsNotRequired */\n      url: string,\n      /** @docsNotRequired */\n      public urlAfterRedirects: string,\n      /** @docsNotRequired */\n      public state: RouterStateSnapshot) {\n    super(id, url);\n  }\n\n  override toString(): string {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${\n        this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see `RouteConfigLoadEnd`\n *\n * @publicApi\n */\nexport class RouteConfigLoadStart {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see `RouteConfigLoadStart`\n *\n * @publicApi\n */\nexport class RouteConfigLoadEnd {\n  constructor(\n      /** @docsNotRequired */\n      public route: Route) {}\n  toString(): string {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ChildActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart`\n * @publicApi\n */\nexport class ChildActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationStart {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport class ActivationEnd {\n  constructor(\n      /** @docsNotRequired */\n      public snapshot: ActivatedRouteSnapshot) {}\n  toString(): string {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport class Scroll {\n  constructor(\n      /** @docsNotRequired */\n      readonly routerEvent: NavigationEnd,\n\n      /** @docsNotRequired */\n      readonly position: [number, number]|null,\n\n      /** @docsNotRequired */\n      readonly anchor: string|null) {}\n\n  toString(): string {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The events occur in the following sequence:\n *\n * * [NavigationStart](api/router/NavigationStart): Navigation starts.\n * * [RouteConfigLoadStart](api/router/RouteConfigLoadStart): Before\n * the router [lazy loads](/guide/router#lazy-loading) a route configuration.\n * * [RouteConfigLoadEnd](api/router/RouteConfigLoadEnd): After a route has been lazy loaded.\n * * [RoutesRecognized](api/router/RoutesRecognized): When the router parses the URL\n * and the routes are recognized.\n * * [GuardsCheckStart](api/router/GuardsCheckStart): When the router begins the *guards*\n * phase of routing.\n * * [ChildActivationStart](api/router/ChildActivationStart): When the router\n * begins activating a route's children.\n * * [ActivationStart](api/router/ActivationStart): When the router begins activating a route.\n * * [GuardsCheckEnd](api/router/GuardsCheckEnd): When the router finishes the *guards*\n * phase of routing successfully.\n * * [ResolveStart](api/router/ResolveStart): When the router begins the *resolve*\n * phase of routing.\n * * [ResolveEnd](api/router/ResolveEnd): When the router finishes the *resolve*\n * phase of routing successfully.\n * * [ChildActivationEnd](api/router/ChildActivationEnd): When the router finishes\n * activating a route's children.\n * * [ActivationEnd](api/router/ActivationEnd): When the router finishes activating a route.\n * * [NavigationEnd](api/router/NavigationEnd): When navigation ends successfully.\n * * [NavigationCancel](api/router/NavigationCancel): When navigation is canceled.\n * * [NavigationError](api/router/NavigationError): When navigation fails\n * due to an unexpected error.\n * * [Scroll](api/router/Scroll): When the user scrolls.\n *\n * @publicApi\n */\nexport type Event = RouterEvent|RouteConfigLoadStart|RouteConfigLoadEnd|ChildActivationStart|\n    ChildActivationEnd|ActivationStart|ActivationEnd|Scroll;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './config';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport type Params = {\n  [key: string]: any;\n};\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport interface ParamMap {\n  /**\n   * Reports whether the map contains a given parameter.\n   * @param name The parameter name.\n   * @returns True if the map contains the given parameter, false otherwise.\n   */\n  has(name: string): boolean;\n  /**\n   * Retrieves a single value for a parameter.\n   * @param name The parameter name.\n   * @return The parameter's single value,\n   * or the first value if the parameter has multiple values,\n   * or `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Retrieves multiple values for a parameter.\n   * @param name The parameter name.\n   * @return An array containing one or more values,\n   * or an empty array if there is no such parameter.\n   *\n   */\n  getAll(name: string): string[];\n\n  /** Names of the parameters in the map. */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) {\n    this.params = params || {};\n  }\n\n  has(name: string): boolean {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n\n  get(name: string): string|null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] {\n    return Object.keys(this.params);\n  }\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport function navigationCancelingError(message: string) {\n  const error = Error('NavigationCancelingError: ' + message);\n  (error as any)[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n\nexport function isNavigationCancelingError(error: Error) {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n\n// Matches the route configuration (`route`) against the actual URL (`segments`).\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const parts = route.path!.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {from, Observable, of} from 'rxjs';\n\nimport {Params} from '../shared';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(a: Params, b: Params): boolean {\n  // While `undefined` should never be possible, it would sometimes be the case in IE 11\n  // and pre-chromium Edge. The check below accounts for this edge case.\n  const k1 = a ? Object.keys(a) : undefined;\n  const k2 = b ? Object.keys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key: string;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Test equality for arrays of strings or a string.\n */\nexport function equalArraysOrString(a: string|string[], b: string|string[]) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\n/**\n * Verifys all booleans in an array are `true`.\n */\nexport function and(bools: boolean[]): boolean {\n  return !bools.some(v => !v);\n}\n\nexport function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: string) => void): void {\n  for (const prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nexport function wrapIntoObservable<T>(value: T|Promise<T>|Observable<T>): Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {convertToParamMap, ParamMap, Params, PRIMARY_OUTLET} from './shared';\nimport {equalArraysOrString, forEach, shallowEqual} from './utils/collection';\n\nexport function createEmptyUrlTree() {\n  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);\n}\n\n/**\n * A set of options which specify how to determine if a `UrlTree` is active, given the `UrlTree`\n * for the current router state.\n *\n * @publicApi\n * @see Router.isActive\n */\nexport interface IsActiveMatchOptions {\n  /**\n   * Defines the strategy for comparing the matrix parameters of two `UrlTree`s.\n   *\n   * The matrix parameter matching is dependent on the strategy for matching the\n   * segments. That is, if the `paths` option is set to `'subset'`, only\n   * the matrix parameters of the matching segments will be compared.\n   *\n   * - `'exact'`: Requires that matching segments also have exact matrix parameter\n   * matches.\n   * - `'subset'`: The matching segments in the router's active `UrlTree` may contain\n   * extra matrix parameters, but those that exist in the `UrlTree` in question must match.\n   * - `'ignored'`: When comparing `UrlTree`s, matrix params will be ignored.\n   */\n  matrixParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the query parameters of two `UrlTree`s.\n   *\n   * - `'exact'`: the query parameters must match exactly.\n   * - `'subset'`: the active `UrlTree` may contain extra parameters,\n   * but must match the key and value of any that exist in the `UrlTree` in question.\n   * - `'ignored'`: When comparing `UrlTree`s, query params will be ignored.\n   */\n  queryParams: 'exact'|'subset'|'ignored';\n  /**\n   * Defines the strategy for comparing the `UrlSegment`s of the `UrlTree`s.\n   *\n   * - `'exact'`: all segments in each `UrlTree` must match.\n   * - `'subset'`: a `UrlTree` will be determined to be active if it\n   * is a subtree of the active route. That is, the active route may contain extra\n   * segments, but must at least have all the segements of the `UrlTree` in question.\n   */\n  paths: 'exact'|'subset';\n  /**\n   * - 'exact'`: indicates that the `UrlTree` fragments must be equal.\n   * - `'ignored'`: the fragments will not be compared when determining if a\n   * `UrlTree` is active.\n   */\n  fragment: 'exact'|'ignored';\n}\n\ntype ParamMatchOptions = 'exact'|'subset'|'ignored';\n\ntype PathCompareFn =\n    (container: UrlSegmentGroup, containee: UrlSegmentGroup, matrixParams: ParamMatchOptions) =>\n        boolean;\ntype ParamCompareFn = (container: Params, containee: Params) => boolean;\n\nconst pathCompareMap: Record<IsActiveMatchOptions['paths'], PathCompareFn> = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup,\n};\nconst paramCompareMap: Record<ParamMatchOptions, ParamCompareFn> = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true,\n};\n\nexport function containsTree(\n    container: UrlTree, containee: UrlTree, options: IsActiveMatchOptions): boolean {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n      paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n      !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\n\nfunction equalParams(container: Params, containee: Pa