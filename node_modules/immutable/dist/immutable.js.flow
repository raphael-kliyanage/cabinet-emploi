/**
 * This file provides type definitions for use with the Flow type checker.
 *
 * An important caveat when using these definitions is that the types for
 * `Collection.Keyed`, `Collection.Indexed`, `Seq.Keyed`, and so on are stubs.
 * When referring to those types, you can get the proper definitions by
 * importing the types `KeyedCollection`, `IndexedCollection`, `KeyedSeq`, etc.
 * For example,
 *
 *     import { Seq } from 'immutable'
 *     import type { IndexedCollection, IndexedSeq } from 'immutable'
 *
 *     const someSeq: IndexedSeq<number> = Seq.Indexed.of(1, 2, 3)
 *
 *     function takesASeq<T, TS: IndexedCollection<T>>(iter: TS): TS {
 *       return iter.butLast()
 *     }
 *
 *     takesASeq(someSeq)
 *
 * @flow strict
 */

// Helper type that represents plain objects allowed as arguments to
// some constructors and functions.
type PlainObjInput<K, V> = { +[key: K]: V, __proto__: null };

type K<T> = $Keys<T>;

// Helper types to extract the "keys" and "values" use by the *In() methods.
type $KeyOf<C> = $Call<
  (<K>(?_Collection<K, mixed>) => K) &
    (<T>(?$ReadOnlyArray<T>) => number) &
    (<T>(?RecordInstance<T> | T) => $Keys<T>) &
    (<T: Object>(T) => $Keys<T>),
  C
>;

type $ValOf<C, K = $KeyOf<C>> = $Call<
  (<V>(?_Collection<any, V>) => V) &
    (<T>(?$ReadOnlyArray<T>) => T) &
    (<T, K: $Keys<T>>(?RecordInstance<T> | T, K) => $ElementType<T, K>) &
    (<T: Object>(T) => $Values<T>),
  C,
  K
>;

type $IterableOf<C> = $Call<
  (<V: Array<any> | IndexedCollection<any> | SetCollection<any>>(
    V
  ) => Iterable<$ValOf<V>>) &
    (<
      V:
        | KeyedCollection<any, any>
        | RecordInstance<any>
        | PlainObjInput<any, any>
    >(
      V
    ) => Iterable<[$KeyOf<V>, $ValOf<V>]>),
  C
>;

declare class _Collection<K, +V> implements ValueObject {
  equals(other: mixed): boolean;
  hashCode(): number;
  get(key: K, ..._: []): V | void;
  get<NSV>(key: K, notSetValue: NSV): V | NSV;
  has(key: K): boolean;
  includes(value: V): boolean;
  contains(value: V): boolean;
  first<NSV>(notSetValue?: NSV): V | NSV;
  last<NSV>(notSetValue?: NSV): V | NSV;

  hasIn(keyPath: Iterable<mixed>): boolean;

  getIn(keyPath: [], notSetValue?: mixed): this;
  getIn<NSV>(keyPath: [K], notSetValue: NSV): V | NSV;
  getIn<NSV, K2: $KeyOf<V>>(
    keyPath: [K, K2],
    notSetValue: NSV
  ): $ValOf<V, K2> | NSV;
  getIn<NSV, K2: $KeyOf<V>, K3: $KeyOf<$ValOf<V, K2>>>(
    keyPath: [K, K2, K3],
    notSetValue: NSV
  ): $ValOf<$ValOf<V, K2>, K3> | NSV;
  getIn<
    NSV,
    K2: $KeyOf<V>,
    K3: $KeyOf<$ValOf<V, K2>>,
    K4: $KeyOf<$ValOf<$ValOf<V, K2>, K3>>
  >(
    keyPath: [K, K2, K3, K4],
    notSetValue: NSV
  ): $ValOf<$ValOf<$ValOf<V, K2>, K3>, K4> | NSV;
  getIn<
    NSV,
    K2: $KeyOf<V>,
    K3: $KeyOf<$ValOf<V, K2>>,
    K4: $KeyOf<$ValOf<$ValOf<V, K2>, K3>>,
    K5: $KeyOf<$ValOf<$ValOf<$ValOf<V, K2>, K3>, K4>>
  >(
    keyPath: [K, K2, K3, K4, K5],
    notSetValue: NSV
  ): $ValOf<$ValOf<$ValOf<$ValOf<V, K2>, K3>, K4>, K5> | NSV;

  update<U>(updater: (value: this) => U): U;

  toJS(): Array<any> | { [key: string]: mixed };
  toJSON(): Array<V> | { [key: string]: V };
  toArray(): Array<V> | Array<[K, V]>;
  toObject(): { [key: string]: V };
  toMap(): Map<K, V>;
  toOrderedMap(): OrderedMap<K, V>;
  toSet(): Set<V>;
  toOrderedSet(): OrderedSet<V>;
  toList(): List<V>;
  toStack(): Stack<V>;
  toSeq(): Seq<K, V>;
  toKeyedSeq(): KeyedSeq<K, V>;
  toIndexedSeq(): IndexedSeq<V>;
  toSetSeq(): SetSeq<V>;

  keys(): Iterator<K>;
  values(): Iterator<V>;
  entries(): Iterator<[K, V]>;

  keySeq(): IndexedSeq<K>;
  valueSeq(): IndexedSeq<V>;
  entrySeq(): IndexedSeq<[K, V]>;

  reverse(): this;
  sort(comparator?: (valueA: V, valueB: V) => number): this;

  sortBy<C>(
    comparatorValueMapper: (value: V, key: K, iter: this) => C,
    comparator?: (valueA: C, valueB: C) => number
  ): this;

  groupBy<G>(
    grouper: (value: V, key: K, iter: this) => G,
    context?: mixed
  ): KeyedSeq<G, this>;

  forEach(
    sideEffect: (value: V, key: K, iter: this) => any,
    context?: mixed
  ): number;

  slice(begin?: number, end?: number): this;
  rest(): this;
  butLast(): this;
  skip(amount: number): this;
  skipLast(amount: number): this;
  skipWhile(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): this;
  skipUntil(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): this;
  take(amount: number): this;
  takeLast(amount: number): this;
  takeWhile(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): this;
  takeUntil(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): this;

  filterNot(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): this;

  reduce<R>(
    reducer: (reduction: R, value: V, key: K, iter: this) => R,
    initialReduction: R,
    context?: mixed
  ): R;
  reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;

  reduceRight<R>(
    reducer: (reduction: R, value: V, key: K, iter: this) => R,
    initialReduction: R,
    context?: mixed
  ): R;
  reduceRight<R>(
    reducer: (reduction: V | R, value: V, key: K, iter: this) => R
  ): R;

  every(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): boolean;
  some(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): boolean;
  join(separator?: string): string;
  isEmpty(): boolean;
  count(
    predicate?: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): number;
  countBy<G>(
    grouper: (value: V, key: K, iter: this) => G,
    context?: mixed
  ): Map<G, number>;

  find<NSV>(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed,
    notSetValue?: NSV
  ): V | NSV;
  findLast<NSV>(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed,
    notSetValue?: NSV
  ): V | NSV;

  findEntry(predicate: (value: V, key: K, iter: this) => mixed): [K, V] | void;
  findLastEntry(
    predicate: (value: V, key: K, iter: this) => mixed
  ): [K, V] | void;

  findKey(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): K | void;
  findLastKey(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): K | void;

  keyOf(searchValue: V): K | void;
  lastKeyOf(searchValue: V): K | void;

  max(comparator?: (valueA: V, valueB: V) => number): V;
  maxBy<C>(
    comparatorValueMapper: (value: V, key: K, iter: this) => C,
    comparator?: (valueA: C, valueB: C) => number
  ): V;
  min(comparator?: (valueA: V, valueB: V) => number): V;
  minBy<C>(
    comparatorValueMapper: (value: V, key: K, iter: this) => C,
    comparator?: (valueA: C, valueB: C) => number
  ): V;

  isSubset(iter: Iterable<V>): boolean;
  isSuperset(iter: Iterable<V>): boolean;
}

declare function isImmutable(
  maybeImmutable: mixed
): boolean %checks(maybeImmutable instanceof Collection);
declare function isCollection(
  maybeCollection: mixed
): boolean %checks(maybeCollection instanceof Collection);
declare function isKeyed(
  maybeKeyed: mixed
): boolean %checks(maybeKeyed instanceof KeyedCollection);
declare function isIndexed(
  maybeIndexed: mixed
): boolean %checks(maybeIndexed instanceof IndexedCollection);
declare function isAssociative(
  maybeAssociative: mixed
): boolean %checks(maybeAssociative instanceof KeyedCollection ||
  maybeAssociative instanceof IndexedCollection);
declare function isOrdered(
  maybeOrdered: mixed
): boolean %checks(maybeOrdered instanceof IndexedCollection ||
  maybeOrdered instanceof OrderedMap ||
  maybeOrdered instanceof OrderedSet);
declare function isValueObject(maybeValue: mixed): boolean;

declare function isSeq(maybeSeq: any): boolean %checks(maybeSeq instanceof Seq);
declare function isList(maybeList: any): boolean %checks(maybeList instanceof
  List);
declare function isMap(maybeMap: any): boolean %checks(maybeMap instanceof Map);
declare function isOrderedMap(
  maybeOrderedMap: any
): boolean %checks(maybeOrderedMap instanceof OrderedMap);
declare function isStack(maybeStack: any): boolean %checks(maybeStack instanceof
  Stack);
declare function isSet(maybeSet: any): boolean %checks(maybeSet instanceof Set);
declare function isOrderedSet(
  maybeOrderedSet: any
): boolean %checks(maybeOrderedSet instanceof OrderedSet);
declare function isRecord(
  maybeRecord: any
): boolean %checks(maybeRecord instanceof Record);

declare interface ValueObject {
  equals(other: mixed): boolean;
  hashCode(): number;
}

declare class Collection<K, +V> extends _Collection<K, V> {
  static Keyed: typeof KeyedCollection;
  static Indexed: typeof IndexedCollection;
  static Set: typeof SetCollection;

  static isCollection: typeof isCollection;
  static isKeyed: typeof isKeyed;
  static isIndexed: typeof isIndexed;
  static isAssociative: typeof isAssociative;
  static isOrdered: typeof isOrdered;
}

declare class KeyedCollection<K, +V> extends Collection<K, V> {
  static <K, V>(
    values?: Iterable<[K, V]> | PlainObjInput<K, V>
  ): KeyedCollection<K, V>;

  toJS(): { [key: string]: mixed };
  toJSON(): { [key: string]: V };
  toArray(): Array<[K, V]>;
  @@iterator(): Iterator<[K, V]>;
  toSeq(): KeyedSeq<K, V>;
  flip(): KeyedCollection<V, K>;

  concat<KC, VC>(
    ...iters: Array<Iterable<[KC, VC]> | PlainObjInput<KC, VC>>
  ): KeyedCollection<K | KC, V | VC>;

  filter(predicate: typeof Boolean): KeyedCollection<K, $NonMaybeType<V>>;
  filter(
    predicate: (value: V, key: K, iter: this) => mixed,
    context?: mixed
  ): KeyedCollection<K, V>;

  map<M>(
    mapper: (value: V, key: K, iter: this) => M,
    context?: mixed
  ): KeyedCollection<K, M>;

  mapKeys<M>(
    mapper: (key: K, value: V, iter: this) => M,
    context?: mixed
  ): KeyedCollection<M, V>;

  mapEntries<KM, VM>(
    mapper: (entry: [K, V], index: number, iter: this) => [KM, VM],
    context?: mixed
  ): KeyedCollection<KM, VM>;

  flatMap<KM, VM>(
    mapper: (value: V, key: K, iter: this) => Iterable<[KM, VM]>,
    context?: mixed
  ): KeyedCollection<KM, VM>;

  flatten(depth?: number): KeyedCollection<any, any>;
  flatten(shallow?: boolean): KeyedCollection<any, any>;
}

Collection.Keyed = KeyedCollection;

declare class IndexedCollection<+T> extends Collection<number, T> {
  static <T>(iter?: Iterable<T>): IndexedCollection<T>;

  toJS(): Array<mixed>;
  toJSON(): Array<T>;
  toArray(): Array<T>;
  @@iterator(): Iterator<T>;
  toSeq(): IndexedSeq<T>;
  fromEntrySeq<K, V>(): KeyedSeq<K, V>;
  interpose(separator: T): this;
  interleave(...collections: Iterable<T>[]): this;
  splice(index: number, removeNum: number, ...values: T[]): this;

  zip<A>(a: Iterable<A>, ..._: []): IndexedCollection<[T, A]>;
  zip<A, B>(
    a: Iterable<A>,
    b: Iterable<B>,
    ..._: []
  ): IndexedCollection<[T, A, B]>;
  zip<A, B, C>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    ..._: []
  ): IndexedCollection<[T, A, B, C]>;
  zip<A, B, C, D>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    ..._: []
  ): IndexedCollection<[T, A, B, C, D]>;
  zip<A, B, C, D, E>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    e: Iterable<E>,
    ..._: []
  ): IndexedCollection<[T, A, B, C, D, E]>;

  zipAll<A>(a: Iterable<A>, ..._: []): IndexedCollection<[T | void, A | void]>;
  zipAll<A, B>(
    a: Iterable<A>,
    b: Iterable<B>,
    ..._: []
  ): IndexedCollection<[T | void, A | void, B | void]>;
  zipAll<A, B, C>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    ..._: []
  ): IndexedCollection<[T | void, A | void, B | void, C | void]>;
  zipAll<A, B, C, D>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    ..._: []
  ): IndexedCollection<[T | void, A | void, B | void, C | void, D | void]>;
  zipAll<A, B, C, D, E>(
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    e: Iterable<E>,
    ..._: []
  ): IndexedCollection<
    [T | void, A | void, B | void, C | void, D | void, E | void]
  >;

  zipWith<A, R>(
    zipper: (value: T, a: A) => R,
    a: Iterable<A>,
    ..._: []
  ): IndexedCollection<R>;
  zipWith<A, B, R>(
    zipper: (value: T, a: A, b: B) => R,
    a: Iterable<A>,
    b: Iterable<B>,
    ..._: []
  ): IndexedCollection<R>;
  zipWith<A, B, C, R>(
    zipper: (value: T, a: A, b: B, c: C) => R,
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    ..._: []
  ): IndexedCollection<R>;
  zipWith<A, B, C, D, R>(
    zipper: (value: T, a: A, b: B, c: C, d: D) => R,
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    ..._: []
  ): IndexedCollection<R>;
  zipWith<A, B, C, D, E, R>(
    zipper: (value: T, a: A, b: B, c: C, d: D, e: E) => R,
    a: Iterable<A>,
    b: Iterable<B>,
    c: Iterable<C>,
    d: Iterable<D>,
    e: Iterable<E>,
    ..._: []
  ): IndexedCollection<R>;

  indexOf(searchValue: T): number;
  lastIndexOf(searchValue: T): number;
  findIndex(
    predicate: (value: T, index: number, iter: this) => mixed,
    context?: mixed
  ): number;
  findLastIndex(
    predicate: (value: T, index: number, iter: this) => mixed,
    context?: mixed
  ): number;

  concat<C>(...iters: Array<Iterable<C> | C>): IndexedCollection<T | C>;

  filter(predicate: typeof Boolean): IndexedCollection<$NonMaybeType<T>>;
  filter(
    predicate: (value: T, index: number, iter: this) => mixed,
    context?: mixed
  ): IndexedCollection<T>;

  map<M>(
    mapper: (value: T, index: number, iter: this) => M,
    context?: mixed
  ): IndexedCollection<M>;

  flatMap<M>(
    mapper: (value: T, index: number, iter: this) => Iterable<M>,
    context?: mixed
  ): IndexedCollection<M>;

  flatten(de